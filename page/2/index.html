<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Caijialinxx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Caijialinxx">
<meta property="og:url" content="https://caijialinxx.github.io/page/2/index.html">
<meta property="og:site_name" content="Caijialinxx">
<meta property="og:locale">
<meta property="article:author" content="caijialinxx">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Caijialinxx" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Caijialinxx</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://caijialinxx.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-git" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/04/06/git/" class="article-date">
  <time class="dt-published" datetime="2019-04-06T10:11:05.000Z" itemprop="datePublished">2019-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/04/06/git/">Git 中的后悔药</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>前言：</p>
<ul>
<li><code>git fsck</code> &amp; <code>git stash apply &lt;commit_id&gt;</code> ：针对 stash 存储的误删</li>
<li><code>git checkout -- &lt;file&gt;</code> ：针对工作区的修改</li>
<li><code>git reset</code> ：针对暂存区的修改</li>
</ul>
<h2 id="💊fsck-——-针对-stash-存储的误删"><a href="#💊fsck-——-针对-stash-存储的误删" class="headerlink" title="💊fsck —— 针对 stash 存储的误删"></a>💊fsck —— 针对 stash 存储的误删</h2><p>在不同的公司，技术团队在代码仓库中的协同工作流程可能会有不同。我公司就是在 dev 分支上进行开发，合并更新的流程基本就是下面：</p>
<ol>
<li><code>git stash</code> 存储自己在 dev 上做的修改（新建的文件是不会被存储起来的）</li>
<li><code>git pull</code> 拉取远程仓库中的 dev 的更新</li>
<li><code>git stash pop</code> 弹出存储的修改（有冲突的话就解决冲突）</li>
<li>然后就是添加文件并提交修改那些操作。</li>
</ol>
<p>那么我在工作中，遇到最让我窒息、心痛如绞的事情就是：我亲手把自己 stash 的修改给 clear 了……….</p>
<p>神操作如下：</p>
<ol>
<li><p>啊，终于可以提交了，我先 <code>git stash</code> 存起来先</p>
</li>
<li><p>那么接下来查查看我的存储仓记录 <code>git stash clear</code> （一失足成千古恨）</p>
</li>
<li><p>嗯？为什么没有显示存储记录？</p>
</li>
<li><p>？？？我执行了 <code>git stash clear</code> ？？？ CLEAR？？？？我不是要 <code>git stash list</code> 的吗？？？<br><img src="http://wx4.sinaimg.cn/bmiddle/006Cmetyly1fiqiy4pl49j30ji0ji76r.jpg" alt="快叫120！"></p>
</li>
<li><p>我不信，一定没有清空掉的， <code>git stash list</code> ………<br> (Sorry, the list you checked is empty. Du… Du… Du…)</p>
</li>
<li><p>我还是不信，可能我没有 stash 到，还在工作区里。 <code>git status</code> ……..<br> (Sorry, the list you checked is empty. Du… Du… Du…)<br><img src="http://wx2.sinaimg.cn/bmiddle/006Cmetyly1fiqiy3lo8fj30hs0hjjsm.jpg" alt="我要冷静，冷静！"></p>
</li>
</ol>
<p><img src="http://img.soogif.com/eRbY86K0GLTliVxr5IxQozeR4mMcZ59O.gif_s400x0" alt="哇的一声哭出来"><br><img src="http://img.soogif.com/zwkRqLIh6wFXoH1oYpqIlWF09rAE8AJM.gif_s400x0" alt="这不是真的"><br><img src="http://img.soogif.com/IgA7kfbo8vght7ulLXx5DZc4Cq35pkCm.gif_s400x0" alt="我的心好痛"></p>
<p>不哭，一定有解决方法的！<br><img src="http://img.soogif.com/rFZAtRGF1OA0LzyYHYp57nBiL1HHrVDG.gif_s400x0" alt="一定有解决方法的！"></p>
<p>掉坑里的果然不止我一个人，各路大佬介绍了自己的解决方法，我找到符合自己的方法：</p>
<ol>
<li><strong><code>git fsck</code></strong> 查询仓库中所有未被其他对象引用的对象，这密密麻麻地列出了一摞（我记得当时不是时间顺序排序的，但是今天一看好像又是时间顺序的）。</li>
<li>于是我只能 <strong><code>git show &lt;commit_id&gt;</code></strong> 一个个打开来看。</li>
<li>经过漫长的版本查找后，我终于找到了离上一次修改最近的记录！最后 <strong><code>git stash apply &lt;commit_id&gt;</code></strong> 。谢天谢地，回来了！</li>
</ol>
<p><img src="https://i.loli.net/2019/04/17/5cb6cece961fe.jpg" alt="千里寻子终得你"></p>
<h2 id="💊checkout-——-针对工作区的修改"><a href="#💊checkout-——-针对工作区的修改" class="headerlink" title="💊checkout —— 针对工作区的修改"></a>💊checkout —— 针对工作区的修改</h2><p>对于在工作区的修改，还没执行 <code>git add</code> 等操作，此时若是想放弃工作区的全部修改，只需要：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;需要撤销修改的文件名&gt;</span><br></pre></td></tr></table></figure>

<p>注意：这个不针对 Untracked 的文件哦～</p>
<h2 id="💊reset-——-针对暂存区的修改"><a href="#💊reset-——-针对暂存区的修改" class="headerlink" title="💊reset —— 针对暂存区的修改"></a>💊reset —— 针对暂存区的修改</h2><p>对于刚执行完 <code>git add</code> 把文件添加到暂存区的修改，此时若是想放弃暂存区某个文件的修改，只需要：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD &lt;需要撤销修改的文件名&gt;</span><br></pre></td></tr></table></figure>

<p>而如果你已经执行了 <code>git commit</code> 将这些暂存区的文件提交，那你只能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^                ## 将 HEAD 回退到上一个版本</span><br><span class="line">git reset --hard HEAD@&#123;&lt;index&gt;&#125;       ## 将 HEAD 回退到第 index 个版本</span><br><span class="line">git reset --hard &lt;commit_id&gt;          ## 将 HEAD 指向指定的 commit_id 版本</span><br><span class="line"></span><br><span class="line">git log         ## 查看提交的历史</span><br><span class="line">git reflog      ## 查看 HEAD 移动的历史记录，从而回到任意版本</span><br></pre></td></tr></table></figure>
<p>注意：这个操作非常危险！⚠️如果你的工作区中还有已跟踪的修改文件未提交，执行这个操作将会丢失你的这些文件！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://caijialinxx.github.io/2019/04/06/git/" data-id="cm2uc0mbw000lpggphj6v8fq9" data-title="Git 中的后悔药" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Notes/" rel="tag">Notes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B7%A5%E4%BD%9C/" rel="tag">工作</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-vue-reactivity-implement" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/02/17/vue-reactivity-implement/" class="article-date">
  <time class="dt-published" datetime="2019-02-17T06:10:34.000Z" itemprop="datePublished">2019-02-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/02/17/vue-reactivity-implement/">Vue 双向绑定的实现原理</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>我们都知道， Vue 最大的特点之一就是响应式的双向绑定。那么它的实现原理是怎么样的呢？无论是深入学习 Vue 框架也好，还是作为一个面试常考题也好，这都是前端必须了解的一个问题。那么我们今天就来探索一下它的实现方法。</p>
<h2 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h2><p>Vue 在它的官网中就已经有对它的这个「双向绑定」特性进行说明。详情请戳<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/reactivity.html">传送门</a>。我们可以看到， Vue 会遍历实例的 <code>data</code> 对象的所有属性，并使用 <code>Object.defineProperty</code> 把这些属性全部转为 <code>getter</code> &#x2F; <code>setter</code>。根据 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">MDN</a> 的介绍，我尝试着使用这个方法来做一个简单的模拟实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $person1 = &#123;&#125;,   <span class="comment">// 模拟 vm.$data</span></span><br><span class="line">  person1 = &#123; <span class="attr">name</span>: <span class="string">&#x27;caaa&#x27;</span> &#125;  <span class="comment">// 模拟我们在 Vue 中的 data 选项</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>($person1, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> person1.<span class="property">name</span> &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    person1.<span class="property">name</span> = val</span><br><span class="line">    <span class="comment">// 执行某些操作实现 DOM 局部更新</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发生了更新&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$person1.<span class="property">name</span>             <span class="comment">// &#x27;caaa&#x27;</span></span><br><span class="line">$person1.<span class="property">age</span>              <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 改变 $person1.name */</span></span><br><span class="line">$person1.<span class="property">name</span> = <span class="string">&#x27;jack&#x27;</span>    <span class="comment">// &#x27;发生了更新&#x27;</span></span><br><span class="line">$person1.<span class="property">name</span>             <span class="comment">// &#x27;jack&#x27;</span></span><br><span class="line">person1.<span class="property">name</span>              <span class="comment">// &#x27;jack&#x27;</span></span><br></pre></td></tr></table></figure>


<h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><p>通过上面的例子，我们知道了 Vue 是如何实现响应式原理的，但是「受现代 JavaScript 的限制，Vue 不能检测到对象属性的添加或删除。」例如说，我们对上面的 <code>$person1</code> 添加一个属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 为 $person1 添加 age 属性 */</span></span><br><span class="line">$person1.<span class="property">age</span> = <span class="number">18</span></span><br><span class="line">$person1.<span class="property">age</span>              <span class="comment">// 18</span></span><br><span class="line">person1.<span class="property">age</span>               <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到，即使已经改变了 <code>$person1.age</code> ， <code>person1.age</code> 也依旧没有变化。这是因为 <code>$person1.age</code> 是一个非响应的属性，它并没有 <code>setter</code> 来对它进行追踪。也就是说 <code>$person1.age = 18</code> 其实等同于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>($person1, <span class="string">&#x27;age&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那么要如何在 Vue 中为已创建的实例动态添加新的根级响应式属性呢？ Vue 提供的一个方法是 <code>Vue.set(object, key, value)</code> 。这里不详细举例说明，有兴趣的可以自己去尝试一下。</p>
<p>我想展开讲的是， Vue 3.0 中对于响应式数据的更新。</p>
<p>⬇️</p>
<p>⬇️</p>
<p>⬇️</p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>尤雨溪老师在 VueConf TO 大会上发表了「Vue 3.0 Updates」的演讲，提到了 3.0 版本将使用原生 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"><code>Proxy</code></a> 来取代 <code>Object.defineProperty</code> ，这使得 Vue 可以跳出无法添加或删除响应式属性的局限。那么废话少说，我们立马来用用这聪明的 <code>Proxy</code> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;caaa&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $person2 = <span class="keyword">new</span> <span class="title class_">Proxy</span>(person2, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newVal</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`更新了<span class="subst">$&#123;key&#125;</span>`</span>)</span><br><span class="line">    target[key] = newVal</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$person2.<span class="property">name</span>           <span class="comment">// &#x27;caaa&#x27;</span></span><br><span class="line">$person2.<span class="property">age</span>            <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 改变 $person2.name */</span></span><br><span class="line">$person2.<span class="property">name</span> = <span class="string">&#x27;jack&#x27;</span>  <span class="comment">// &#x27;更新了name&#x27;</span></span><br><span class="line">$person2.<span class="property">name</span>           <span class="comment">// &#x27;jack&#x27;</span></span><br><span class="line">person2.<span class="property">name</span>            <span class="comment">// &#x27;jack&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为 $person2 添加 age 属性 */</span></span><br><span class="line">$person2.<span class="property">age</span> = <span class="number">18</span>       <span class="comment">// &#x27;更新了age&#x27;</span></span><br><span class="line">$person2.<span class="property">age</span>            <span class="comment">// 18</span></span><br><span class="line">person2.<span class="property">age</span>             <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为 $person2 删除 age 属性 */</span></span><br><span class="line"><span class="keyword">delete</span> $person2.<span class="property">age</span>     <span class="comment">// true</span></span><br><span class="line">person2.<span class="property">age</span>             <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>看， <code>person2.age</code> 随着 <code>$person2.age</code> 的改变而作出相同的改变了！这说明 <code>$person2</code> 直接新增的属性也可以是响应式的了～</p>
<p>有点期待 Vue 3.0 的问世了呢🤤 当然 3.0 还有很多其他更新呢，给你<a target="_blank" rel="noopener" href="https://docs.google.com/presentation/d/1yhPGyhQrJcpJI2ZFvBme3pGKaGNiLi709c37svivv0o/edit#slide=id.p">传送门</a>，带你去看「Vue 3.0 Updates」。</p>
<p>本文的演示请点击<a target="_blank" rel="noopener" href="https://jsbin.com/jalunicoya/edit?js,console,output">传送门</a>查看 AND 捣鼓。</p>
<hr>
<p>本文完。</p>
<p>若文中有错误还请指正与包涵！</p>
<p>原文链接：<a href="https://caijialinxx.github.io/2019/02/17/vue-reactivity-implement/">https://caijialinxx.github.io/2019/02/17/vue-reactivity-implement/</a></p>
<p>转载请注明出处。</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/reactivity.html">深入响应式原理</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty | MDN</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy | MDN</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://caijialinxx.github.io/2019/02/17/vue-reactivity-implement/" data-id="cm2uc0mc7001mpggp6yryhccd" data-title="Vue 双向绑定的实现原理" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-oop-in-javascript" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/01/04/oop-in-javascript/" class="article-date">
  <time class="dt-published" datetime="2019-01-04T10:13:49.000Z" itemprop="datePublished">2019-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/01/04/oop-in-javascript/">JavaScript 中的面向对象（继承）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>面向对象，是作为一个程序员经常能够碰到的一个概念。那么到底什么是面向对象编程呢？</p>
<p>有人可能会回答：</p>
<blockquote>
<p>把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）／泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派（dynamic dispatch）。<br>如何用一句话说明什么是面向对象思想？ - Milo Yip的回答 - 知乎<br><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19854505/answer/23421930">https://www.zhihu.com/question/19854505/answer/23421930</a></p>
</blockquote>
<p>总结确实是已经很精辟了，但对于初学者而言，可能看完就懵逼了，我只是想搞懂面向对象是什么意思，怎么给了我更多的概念出来😭</p>
<p>这大概就是所谓的「从入门到放弃」吧… 哈哈哈哈哈</p>
<p>于是这时有人跑出来回答说：</p>
<ul>
<li>无论是面向对象编程还是函数式编程，这些都只是一种编程思想。就像是不同的宗教，有些不允许养猪吃猪肉，有些不允许吃牛肉，有些要求男性戴帽女性盖头…… 你可以信某个教，也可以不信教或者汲取多个教的精华。也就是说，我们只需要关注面向对象的意义，而不必纠结于一个语言或者程序设计到底是遵循或应该遵循什么编程典范。</li>
</ul>
<p><small>这让我想到了咱南北方的饮食差异：北方的粽子是甜的，南方的粽子是咸的；北方人吃完12个饺子后“老板其它菜咋还没上呢”，南方人吃完12个饺子后“老板买单”…😂</small></p>
<p>那么接下来，我们来详细聊聊 JavaScript 是如何体现面向对象思想的，以及继承该如何实现。</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>我现在想要两百块，那么：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hundred1 = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;AA00000000&#x27;</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">unit</span>: <span class="string">&#x27;元&#x27;</span>,</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;红&#x27;</span>,</span><br><span class="line">  <span class="attr">form</span>: <span class="string">&#x27;纸币&#x27;</span>,</span><br><span class="line">  <span class="attr">issue</span>: <span class="string">&#x27;2019-01&#x27;</span>,</span><br><span class="line">  兑换等值商品: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  换两张<span class="number">50</span>块: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hundred2 = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;AA00000001&#x27;</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">unit</span>: <span class="string">&#x27;元&#x27;</span>,</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;红&#x27;</span>,</span><br><span class="line">  <span class="attr">form</span>: <span class="string">&#x27;纸币&#x27;</span>,</span><br><span class="line">  <span class="attr">issue</span>: <span class="string">&#x27;2019-01&#x27;</span>,</span><br><span class="line">  兑换等值商品: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  换两张<span class="number">50</span>块: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>于是我就可以用这两百块钱去吃椰子鸡了。</p>
<h3 id="构造函数-原型对象"><a href="#构造函数-原型对象" class="headerlink" title="构造函数 &amp; 原型对象"></a>构造函数 &amp; 原型对象</h3><p>哎呀，椰子鸡好吃，可是钱也花光了。不行，我得再造钱来用，但我不想让别人看到我是怎么造的！所以我要做一个百元印钞机，把这些过程放百元进印钞机里，我只要输入每张钞票的 ID ，再按印刷键，就可以刷刷刷出百元大钞🤤。同时，这个印钞机要智能一点，不要老是一个个重复得去刻面额、单位、喷颜色等，直接给它引用个百元钞模版，这样能省点墨水😎。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 百元印钞机——构造函数 Hundred()</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HundredYuan</span> (<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> money = &#123;&#125;</span><br><span class="line">  money.<span class="property">__proto__</span> = <span class="title class_">HundredYuan</span>.<span class="property"><span class="keyword">prototype</span></span>   <span class="comment">// 实际开发中不能这么写，会严重影响性能，详见 MDN 解释：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto</span></span><br><span class="line">  money.<span class="property">id</span> = id</span><br><span class="line">  <span class="keyword">return</span> money</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 百元钞模版——原型对象 HundredYuan.prototype</span></span><br><span class="line"><span class="title class_">HundredYuan</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">unit</span>: <span class="string">&#x27;元&#x27;</span>,</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;红&#x27;</span>,</span><br><span class="line">  <span class="attr">form</span>: <span class="string">&#x27;纸币&#x27;</span>,</span><br><span class="line">  <span class="attr">issue</span>: <span class="string">&#x27;2019-01&#x27;</span>,</span><br><span class="line">  兑换等值商品: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  换两张<span class="number">50</span>块: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给老子来五百，装进钱包里</span></span><br><span class="line"><span class="keyword">var</span> wallet = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">2</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> id = <span class="string">&#x27;AA0000000&#x27;</span> + i</span><br><span class="line">  wallet.<span class="title function_">push</span>(<span class="title class_">HundredYuan</span>(id))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wallet            <span class="comment">// 5张100编号分别是 &#x27;AA00000002&#x27;, &#x27;AA00000003&#x27;, &#x27;AA00000004&#x27;, &#x27;AA00000005&#x27;, &#x27;AA00000006&#x27;</span></span><br><span class="line">wallet[<span class="number">0</span>].<span class="property">value</span>   <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个百元印钞机，就是我们所说的「构造函数」，它能生成一个实例对象（也就是造出一张张百元钞），同时它还用 <code>prototype</code> 属性来引用一个存放共同属性的「原型对象」（百元钞模版）。把造钱的过程放进这个百元印钞机，就是「封装」。这样我们就能很好地理解了封装的意义了——隐藏某一方法的具体运行步骤。</p>
</blockquote>
<h3 id="new-this"><a href="#new-this" class="headerlink" title="new &amp; this"></a>new &amp; this</h3><p>从上面的例子我们可以知道，构造函数的套路就是：</p>
<ol>
<li>创建一个空的新对象</li>
<li>为这个新对象添加公有属性，即 <code>新对象.__proto__</code> 属性指向构造函数的原型（ <code>构造函数.prototype</code> 引用的对象）</li>
<li>为这个新对象添加自有的属性</li>
<li>返回这个新对象。</li>
</ol>
<p>既然套路都一样，那为什么不把这个套路变得贴心一点呢？于是有了 <code>new</code> 操作符，它可以帮我们省去 1、2、4 这三个动作，我们只需专注于添加对象的自有属性即可。同时， JS 之父还帮我们规定好，创建的空对象统一命名为 <code>this</code> 。于是，上面的函数我们可以写成这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HundredYuan</span> (<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="comment">// var this = &#123;&#125;</span></span><br><span class="line">  <span class="comment">// this.__proto__ = HundredYuan.prototype</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">id</span> = id</span><br><span class="line">  <span class="comment">// return this</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">HundredYuan</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="attr">unit</span>: <span class="string">&#x27;元&#x27;</span>,</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;红&#x27;</span>,</span><br><span class="line">  <span class="attr">form</span>: <span class="string">&#x27;纸币&#x27;</span>,</span><br><span class="line">  <span class="attr">issue</span>: <span class="string">&#x27;2019-01&#x27;</span>,</span><br><span class="line">  兑换等值商品: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  换两张<span class="number">50</span>块: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">HundredYuan</span>(<span class="string">&#x27;AA00000007&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>嘿嘿，有了百元印钞机，富得流油不再是梦🤤。</p>
<p>但是新的问题来了，整天带着一大沓百元大钞出门，要么可能会被乞丐围着，要么可能会有生命危险！不行不行，还是低调点，我需要点小钞。例如五角硬币机：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FiveJiao</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">FiveJiao</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">unit</span>: <span class="string">&#x27;角&#x27;</span>,</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;金&#x27;</span>,</span><br><span class="line">  <span class="attr">form</span>: <span class="string">&#x27;硬币&#x27;</span>,</span><br><span class="line">  <span class="attr">issue</span>: <span class="string">&#x27;2019-01&#x27;</span>,</span><br><span class="line">  兑换等值商品: <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哇，跟百元印钞机好像哦。说不定把它们整一下，就可以弄出一元印钞机、十元印钞机…… 那么我就弄个造钱机，它造的钱都有 <code>兑换等值商品</code> 的功能，我要让 N 元印钞机和 N 角硬币机在不需要自己定义的情况下就能直接用到它爸爸造钱机的 <code>兑换等值商品</code> 功能以及一些属性。这就是我们所谓的「继承」——让子类实例能够拥有父类实例的所有方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类 Money</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Money</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">form</span> = options.<span class="property">form</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">issue</span> = options.<span class="property">issue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Money</span>.<span class="property"><span class="keyword">prototype</span></span>.兑换等值商品 = <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 HundredYuan</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HundredYuan</span>(<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="title class_">Money</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, &#123; <span class="attr">form</span>: <span class="string">&#x27;纸币&#x27;</span>, <span class="attr">issue</span>: <span class="string">&#x27;2019-01&#x27;</span> &#125;)          <span class="comment">// 调用父类 Money 使得子类 HundredYuan 的实例具有父类实例的属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">id</span> = id</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">tempMoney</span> (<span class="params"></span>) &#123; &#125;                     <span class="comment">// 1. 为了使 HundredYuan 的原型能够继承父类 Money 的原型，我们造一个空构造函数</span></span><br><span class="line">tempMoney.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Money</span>.<span class="property"><span class="keyword">prototype</span></span>         <span class="comment">// 2. 父类 Money 的原型赋给空构造函数的原型</span></span><br><span class="line"><span class="title class_">HundredYuan</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">tempMoney</span>()       <span class="comment">// 3. 于是 HundredYuan 的原型间接继承父类 Money 的原型</span></span><br><span class="line"><span class="title class_">HundredYuan</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">value</span> = <span class="number">100</span></span><br><span class="line"><span class="title class_">HundredYuan</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">unit</span> = <span class="string">&#x27;元&#x27;</span></span><br><span class="line"><span class="title class_">HundredYuan</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">color</span> = <span class="string">&#x27;红&#x27;</span></span><br><span class="line"><span class="title class_">HundredYuan</span>.<span class="property"><span class="keyword">prototype</span></span>.换两张<span class="number">50</span>元 = <span class="keyword">function</span> (<span class="params"></span>) &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……以此类推其他印钞机</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">HundredYuan</span>(<span class="string">&#x27;AA00000001&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a><code>Object.create()</code></h3><p><code>Object.create()</code> 方法创建一个新对象，使用现有的对象来提供新创建的对象的 <code>__proto__</code> 。<br>让子类原型继承父类原型的操作看起来太麻烦了，更人性化及正确的写法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HundredYuan</span>(<span class="params">id</span>) &#123;</span><br><span class="line">  <span class="title class_">Money</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, &#123; <span class="attr">form</span>: <span class="string">&#x27;纸币&#x27;</span>, <span class="attr">issue</span>: <span class="string">&#x27;2019-01&#x27;</span> &#125;)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">id</span> = id</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">HundredYuan</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Money</span>.<span class="property"><span class="keyword">prototype</span></span>)  <span class="comment">// 相当于 HundredYuan.prototype.__proto__ = Money.prototype</span></span><br><span class="line"><span class="title class_">HundredYuan</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">HundredYuan</span>         <span class="comment">// 重新指定原型的 constructor</span></span><br><span class="line"><span class="title class_">HundredYuan</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">value</span> = <span class="number">100</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>ES6 引入的「类」是一个特殊的函数，它可以帮助我们进一步简化继承的操作，但它依旧是「基于原型」的而不是引入新的面向对象继承模型，类语法只不过是一种语法糖。</p>
<p>上面的例子用类改造如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类 Money</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">form</span> = options.<span class="property">form</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">issue</span> = options.<span class="property">issue</span></span><br><span class="line">  &#125;</span><br><span class="line">  兑换等值商品 () &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类 HundredYuan</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HundredYuan</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Money</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(&#123; <span class="attr">form</span>: <span class="string">&#x27;纸币&#x27;</span>, <span class="attr">issue</span>: <span class="string">&#x27;2019-01&#x27;</span> &#125;)       <span class="comment">// 调用父类 Money 使得子类 HundredYuan 的实例具有父类实例的属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = id</span><br><span class="line">    <span class="comment">// 在构造函数中的公有属性可以是简单类型，但在类中不可以，所以需要把公有属性放在 constructor 中，作为子类的自有属性。</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="number">100</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">unit</span> = <span class="string">&#x27;元&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = <span class="string">&#x27;红&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  换两张<span class="number">50</span>元 () &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">HundredYuan</span>(<span class="string">&#x27;AA00000001&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用类方法确实简洁明了了许多，但是有个问题就是，它明明是个函数，但却不能被调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="title class_">Money</span>        <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="title class_">Money</span>()             <span class="comment">// Uncaught TypeError: Class constructor Money cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure>

<p>要用类还是用构造函数，你来决定，这里只是提出这一个现象。</p>
<p>希望看完本文的你，能理解到 JavaScript 中的面向对象思想。</p>
<hr>
<p>本文完。</p>
<p>若文中有错误还请指正与包涵！</p>
<p>原文链接：<a href="https://caijialinxx.github.io/2019/01/04/oop-in-javascript/">https://caijialinxx.github.io/2019/01/04/oop-in-javascript/</a></p>
<p>转载请注明出处。</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/oop/index.html">面向对象编程 - JavaScript 教程 - 阮一峰</a></li>
</ul>
<p>拓展阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/23987456">JS 的 new 到底是干什么的？ - 方应杭的文章 - 知乎</a></li>
<li><a href="https://caijialinxx.github.io/2018/10/22/prototype-proto-and-inheritance/">誓死讲清 prototype 、 <strong>proto</strong> 、 原型链与继承 - Caijialinxx</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://caijialinxx.github.io/2019/01/04/oop-in-javascript/" data-id="cm2uc0mc10013pggp5d0n8aoz" data-title="JavaScript 中的面向对象（继承）" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Notes/" rel="tag">Notes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B/" rel="tag">原型</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%A7%E6%89%BF/" rel="tag">继承</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-prototype-proto-and-inheritance" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/22/prototype-proto-and-inheritance/" class="article-date">
  <time class="dt-published" datetime="2018-10-22T07:24:21.000Z" itemprop="datePublished">2018-10-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/22/prototype-proto-and-inheritance/">誓死讲清 prototype 、 __proto__ 、 原型链与继承</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>尽管看过很多解释这些概念的文章，每次看完都觉得自己理解了。但一遇到这类问题的时候，我还是不免会答错。这次博客的诞生原因，就是今天又做错了题😭，我这破记性，恐怕得写一篇自己的博客梳理一下，才能真正记住并理解。</p>
<p>先给你们看看这篇博客的“罪魁祸首”：</p>
<blockquote>
<p>现有如下代码：<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">b</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>()</span><br></pre></td></tr></table></figure><br>问：f.a 和 f.b 都能取到吗？</p>
</blockquote>
<p>好的，你们可以先做做这个题。答案我一会儿告诉你们。现在，我要先来讲讲这题涉及到的知识点（其实叫概念更合适？）：</p>
<ul>
<li>构造函数、实例对象与继承</li>
<li><strong>原型对象</strong>（如 <code>Object.prototype</code>）</li>
<li>（不知道中文名怎么叫或者根本没有名字的） <strong><code>__proto__</code></strong></li>
<li>原型链（prototype chain）</li>
</ul>
<h2 id="构造函数、实例对象与继承"><a href="#构造函数、实例对象与继承" class="headerlink" title="构造函数、实例对象与继承"></a>构造函数、实例对象与继承</h2><p>构造函数就是用来构造（创建）一个实例对象的函数。举个例子就是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 你妈妈 = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.带不带把 = <span class="string">&#x27;不带把&#x27;</span></span><br><span class="line">  <span class="variable language_">this</span>.笑 = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;咯咯咯&#x27;</span> &#125;</span><br><span class="line">  <span class="variable language_">this</span>.撒娇 = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;喵喵喵&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">你妈妈.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  长相: <span class="string">&#x27;美丽动人&#x27;</span>,</span><br><span class="line">  说话: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;叽里呱啦&#x27;</span> &#125;,</span><br><span class="line">  笑: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;嘻嘻嘻&#x27;</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> 你 = <span class="keyword">new</span> 你妈妈()</span><br></pre></td></tr></table></figure>
<p>你就是一个实例对象，你妈妈就是一个构造函数，她把你造出来就是 <strong>new</strong> 了你（不要问我你爸是什么）。你遗传（<strong>继承</strong>）了她的特征（**<code>你妈妈.prototype</code>**），例如你妈美丽动人的长相、说话的方法、笑的方法。此外，她期望你是个女孩，笑得可爱，还会撒娇。<br>于是，你就成了下面这个样子，你需要通过 <strong><code>__proto__</code></strong> 这根生命线连接你妈妈的原型特征：<br><img src="https://i.loli.net/2018/10/22/5bcdaa870a3f6.png" alt="如你妈愿的你" title="如你妈愿的你" /></p>
<p>然而，老天嫉妒你妈脱俗的美貌，决定报复在你的身上，让你变成一个又丑又讨人厌的小孩：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">你.长相 = <span class="string">&#x27;奇丑无比&#x27;</span></span><br><span class="line">你.嚎啕大哭 = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;哇哇哇&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>太可怕了，这真是个悲伤的故事：<br><img src="https://i.loli.net/2018/10/22/5bcdaa871af01.png" alt="变了的你" title="变了的你" /></p>
<p>举了个不是非常恰当的例子，戏精该下场了🙂。不过相信聪明的你们应该懂构造函数和实例对象是什么了吧。目前你只需要记住：</p>
<blockquote>
<p>实例对象被构造（<code>new</code>）了之后能够自动引用（<code>__proto__</code>）其构造函数的原型对象（<code>prototype</code>），同时还可以设置自己的属性或方法，如果与原型对象有同名的属性或方法，则会覆盖原型对象上的属性或方法，优先读取自身的属性或方法。</p>
</blockquote>
<p>好了，看完这节，忘记上面只为帮助理解的例子吧…</p>
<h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p>原型对象，顾名思义，就是一个对象，它包含着所有实例对象需要共享的属性和方法。下面是一些原型对象包含的属性和方法的举例：<br><img src="https://i.loli.net/2018/10/22/5bcdaa86e65d4.png" alt="Object.prototype" title="Object.prototype" /><br><img src="https://i.loli.net/2018/10/22/5bcdaa86ecc71.png" alt="Function.prototype" title="Function.prototype" /><br><img src="https://i.loli.net/2018/10/22/5bcdaa871e5bc.png" alt="Array.prototype" title="Array.prototype" /></p>
<p>这些原型对象都有一个 <code>constructor</code> 属性，它们都指向了自己的构造函数，即</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Function</span>         <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Array</span>               <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Object</span>             <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<img src="https://i.loli.net/2018/10/22/5bcdaa8728cd3.png" alt="原型对象的constructor指向各自的构造函数" title="原型对象的constructor指向各自的构造函数" />

<p>有没有被绕晕😄，与第一节结合起来看，构造函数里的 <code>prototype</code> 是它的原型对象，而这个原型对象里有一个属性 <code>constructor</code> 指向构造函数…(??? hahaha~)</p>
<p>如果你还不理解原型对象是什么，那么请先记住：</p>
<blockquote>
<p>原型对象是一个包含着所有实例对象<strong>需要共享的属性和方法的对象</strong>。</p>
</blockquote>
<h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h2><p>我们在上一节可以看到，这三个原型对象包含的属性和方法不尽相同。例如 <code>Function.prototype</code> 有 <code>call()</code> 方法，而 <code>Array.prototype</code> 和 <code>Object.prototype</code> 没有。但 <code>Function.prototype</code> 和 <code>Array.prototype</code> 都有 <code>__proto__</code> 属性，且它们的值指向相同的 <code>Object.prototype</code> 。<br><img src="https://i.loli.net/2018/10/22/5bcdaa8703644.png" alt="Function.prototype和Array.prototype的__proto__属性指向Object.prototype" title="Function.prototype和Array.prototype的共同属性__proto__属性指向Object.prototype" /></p>
<p>在第一节中，<code>你._proto__ === 你妈妈.prototype</code> ，被创建的实例对象的 <code>__proto__</code> 指向构造函数的原型对象中。整成一个公式就是：</p>
<blockquote>
<p><strong><code>被构造的对象.__proto__ === 构造函数.prototype</code></strong></p>
</blockquote>
<p>那么也就是说 <code>Function.prototype</code> 和 <code>Array.prototype</code> 都是被 <code>Object</code> 构造函数构造出来的。你现在可能已经晕了，没办法理解它们是如何被构造出来的，那么接下来，我又要举造人的例子了（放心，这次保证高级一点），希望能帮助你理解：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 充当 Object</span></span><br><span class="line"><span class="keyword">var</span> 好神仙 = <span class="keyword">function</span>(<span class="params">性别</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.性别 = 性别</span><br><span class="line">&#125;</span><br><span class="line">好神仙.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = 好神仙</span><br><span class="line">好神仙.<span class="property"><span class="keyword">prototype</span></span>.品质 = <span class="string">&#x27;善良&#x27;</span></span><br><span class="line">好神仙.<span class="property"><span class="keyword">prototype</span></span>.修仙 = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">/* 假装这是控制台：</span></span><br><span class="line"><span class="comment"> * 好神仙.prototype</span></span><br><span class="line"><span class="comment"> * &#123;</span></span><br><span class="line"><span class="comment"> *   + 修仙: ƒ ()</span></span><br><span class="line"><span class="comment"> *     品质: &quot;善良&quot;</span></span><br><span class="line"><span class="comment"> *   + constructor: ƒ (性别)</span></span><br><span class="line"><span class="comment"> *     ...</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 充当 Function/Array</span></span><br><span class="line"><span class="keyword">var</span> 葫芦籽 = <span class="keyword">function</span>(<span class="params">排行, 颜色, 技能, 弱点</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.排行 = 排行</span><br><span class="line">  <span class="variable language_">this</span>.颜色 = 颜色</span><br><span class="line">  <span class="variable language_">this</span>.技能 = 技能</span><br><span class="line">  <span class="variable language_">this</span>.弱点 = 弱点</span><br><span class="line">&#125;</span><br><span class="line">葫芦籽.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> 好神仙(<span class="string">&#x27;男&#x27;</span>)                <span class="comment">// 即 Function.prototype = new Object(...)</span></span><br><span class="line">葫芦籽.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = 葫芦籽</span><br><span class="line">葫芦籽.<span class="property"><span class="keyword">prototype</span></span>.叫爷爷 = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;爷爷&#x27;</span> &#125;</span><br><span class="line"><span class="comment">/* 假装这是控制台：</span></span><br><span class="line"><span class="comment"> * 葫芦籽.prototype</span></span><br><span class="line"><span class="comment"> * &#123;</span></span><br><span class="line"><span class="comment"> *   + constructor: ƒ (排行, 颜色, 技能, 弱点)</span></span><br><span class="line"><span class="comment"> *   + 叫爷爷: ƒ ()</span></span><br><span class="line"><span class="comment"> *     性别: &quot;男&quot;</span></span><br><span class="line"><span class="comment"> *   - __proto__:                                 &lt;-- 指向 好神仙.prototype，相当于 Function.prototype.__proto__ 指向 Object.prototype</span></span><br><span class="line"><span class="comment"> *     + 修仙: ƒ ()</span></span><br><span class="line"><span class="comment"> *       品质: &quot;善良&quot;</span></span><br><span class="line"><span class="comment"> *     + constructor: ƒ (性别)</span></span><br><span class="line"><span class="comment"> *       ...</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">葫芦籽.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === 好神仙.<span class="property"><span class="keyword">prototype</span></span>       <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这里例子中，即使葫芦籽自己有个原型对象 <code>葫芦籽.prototype</code> ，这个原型对象也可以通过 <code>__proto__</code> 属性指向上一层原型对象 <code>好神仙.prototype</code> 。同理 <code>Function.prototype</code> 和 <code>Array.prototype</code> 。</p>
<p>上面的例子只是为了解释【Function.prototype和Array.prototype的__proto__属性指向Object.prototype】这个是如何实现的，名词多了看起来确实复杂了，好吧看来第一节的例子又要拿出来用了… 我尝试把 <code>__proto__</code> 删掉你就能知道它的作用了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你.说话()                 <span class="comment">// &quot;叽里呱啦&quot;</span></span><br><span class="line">你.<span class="property">__proto__</span> = <span class="literal">null</span></span><br><span class="line">你.说话()                 <span class="comment">// Uncaught TypeError: 你.说话 is not a function</span></span><br></pre></td></tr></table></figure>
<p>看！删了之后你就说不了话了！因为你自身没有说话这个技能，只好靠妈妈助攻，结果你跟她断绝母女关系了！你妈妈伤心欲绝，挥一挥衣袖，带走所有云彩。所以别随便作死😀</p>
<p>说了那么多，整理一下这一节的内容：</p>
<blockquote>
<ol>
<li><code>__proto__</code> 是实例对象的一个属性，这个属性使得实例对象可以使用其共用的属性和方法。</li>
<li>每当一个实例被构造，其 <code>__proto__</code> 属性就会自动指向构造它的函数的原型对象。记住这个公式： <strong><code>被构造的对象.__proto__ === 构造函数.prototype</code></strong> </li>
<li><code>__proto__</code> 会一层层向上指，直到遇到 <code>null</code> 。</li>
</ol>
</blockquote>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>相信看到这里，你应该知道原型链是个啥子东西了。但操心的我还是会举个栗子的（毕竟我的葫芦娃还没放出来呢😀）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 大娃 = <span class="keyword">new</span> 葫芦籽(<span class="number">1</span>, <span class="string">&#x27;红&#x27;</span>, &#123;</span><br><span class="line">  力壮术: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  巨大化: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;, [<span class="string">&#x27;鲁莽&#x27;</span>, <span class="string">&#x27;不懂随机应变&#x27;</span>])</span><br><span class="line"></span><br><span class="line">大娃.品质                       <span class="comment">// &quot;善良&quot;</span></span><br></pre></td></tr></table></figure>
<p>为什么大娃自身明明没有“品质”这个属性，还是可以读到有值呢？</p>
<ul>
<li>因为有原型链呀~！</li>
</ul>
<p>大娃自身没有，它就是去 <code>大娃.__proto__</code> 里找，发现也没有，就继续走到 <code>大娃.__proto__.__proto__</code> 里找，大娃长舒一口气：“好家伙总算找到了，原来我的品质是善良呀✌”。所以 <code>大娃.品质</code> 实际上是 <code>大娃.__proto__.__proto__.品质</code> 。那么大娃走过来的这一路，就是我们所说的“原型链”。<br><img src="https://i.loli.net/2018/10/23/5bcef2196c722.png" alt="大娃的原型链" title="大娃的原型链" /></p>
<p>好吧，又得拿出第一节的例子… 我们尝试取你的长相是什么值，结果返回是“奇丑无比”，为什么不是“美丽动人”呢！！？（自己心里没点 B tree 吗）。请看下图，不记得老天报复把你变丑了吗？你在自身属性中找到了你的长相，你看到是“奇丑无比”，天空突然电闪雷鸣、雷雨交加，你哭倒在厕所，无力去走原型链找你的最初的样子，于是一蹶不振接受了这个事实（苍天绕过谁）。<br><img src="https://i.loli.net/2018/10/22/5bcdaa871af01.png" alt="变了的你" title="变了的你" /></p>
<p>心情是坏的，但总结还是要做的：</p>
<blockquote>
<p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。  —— <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">继承与原型链 | MDN</a></p>
</blockquote>
<h2 id="大总结"><a href="#大总结" class="headerlink" title="大总结"></a>大总结</h2><p>实例对象被构造了之后，能够自动引用其构造函数的原型对象，即 <code>实例对象.__proto__ === 构造函数.prototype</code> 。当试图访问这个实例的一个属性时，它不仅仅会在自身上搜寻，还会沿着它的原型链向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p>
<p>好了，戏总有演完的时候。小可爱们是不是都要忘了开头的问题了。</p>
<blockquote>
<p>现有如下代码：<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">b</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title function_">F</span>()</span><br></pre></td></tr></table></figure><br>问：f.a 和 f.b 都能取到吗？</p>
</blockquote>
<p>答案是：不说。自己画原型链分析。不然我这篇博客你就白看了！就是这么善变这么傲娇~</p>
<div style="color: transparent"><p>
f.__proto__ === F.prototype
=> f.__proto__.__proto__ === F.prototype.__proto__ === Object.prototype
=> f.__proto__.__proto__.a
</p><p>
f.constructor === f.__proto__.constructor === F
=> f.constructor.__proto__ === F.__proto__ === Function.prototype
=> f.constructor.__proto__.b
</p></div>


<hr>
<p>本文完。</p>
<p>若文中有错误还请指正与包涵！</p>
<p>原文链接：<a href="https://caijialinxx.github.io/2018/10/22/prototype-proto-and-inheritance/">https://caijialinxx.github.io/2018/10/22/prototype-proto-and-inheritance/</a></p>
<p>转载请注明出处。</p>
<p>今天的参考资料我想这么写：</p>
<ul>
<li>如果你想了解一下 prototype 等概念的历史，可以看阮一峰老师写的 <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html">Javascript继承机制的设计思想</a> ，这篇博客有点年头了，顿时觉得自己落后好多好多好多…</li>
<li>如果是初学者的话，建议看 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/56770432/answer/315342130">JS 中 <strong>proto</strong> 和 prototype 存在的意义是什么？ - 方应杭的回答 - 知乎</a> ，方老师循序渐进的解答 + 图文并茂的展示，或许能让你理解得更深一些，另外里面也有很多相关文章链接可以点击阅读。</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/22473059">对原型、原型链、 Function、Object 的理解</a> 这篇文章总结了大量面试常考的关于 <code>prototype</code> 与 <code>__proto__</code> 的关系的公式，可能可以帮助你轻松记忆。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://caijialinxx.github.io/2018/10/22/prototype-proto-and-inheritance/" data-id="cm2uc0mc00010pggpfn1qfgbs" data-title="誓死讲清 prototype 、 __proto__ 、 原型链与继承" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Notes/" rel="tag">Notes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B/" rel="tag">原型</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%A7%E6%89%BF/" rel="tag">继承</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-block-formatting-context" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/15/block-formatting-context/" class="article-date">
  <time class="dt-published" datetime="2018-10-15T12:14:31.000Z" itemprop="datePublished">2018-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/15/block-formatting-context/">BFC（块格式化上下文）的理解及其应用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="理解-BFC"><a href="#理解-BFC" class="headerlink" title="理解 BFC"></a>理解 BFC</h2><p>BFC（Block Formatting Context, 块格式化上下文），根据 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">MDN</a> 的解释，它是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。看这个定义是真的很让人摸不着头脑，简单来说， BFC 就是页面中的一个独立容器，一个页面可以有很多的这样的容器，容器里的子元素与外界互不干扰。先看以下例子，你或许就能知道 BFC 到底是何方神圣了：</p>
<ul>
<li><p>例一、现有一个 <code>div.parent</code> 包裹着它的儿子 <code>div.child</code> ：</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  此时 <code>div.parent</code> 的高度即为其儿子 <code>div.child</code> 的高度 <code>150px</code> 。如果为 <code>div.child</code> 添加左浮动，那么 <code>div.parent</code> 就无法包住它的儿子 <code>div.child</code> ，其高度变为 <code>0</code> （如下图所示）。<br>  <img src="https://i.loli.net/2018/10/15/5bc4589889eaa.png" alt="div.child左浮动"></p>
<p>  但是，如果为 <code>div.parent</code> 创建一个 BFC ，就可以使它包住其儿子。如：</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">display</span>: flow-root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <img src="https://i.loli.net/2018/10/15/5bc458988a369.png" alt="例一"></p>
</li>
<li><p>例二、现有两个兄弟 <code>div.left</code> 和 <code>div.right</code> ，我为 <code>div.left</code> 添加左浮动，使得他们能够并排排列：</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>div.left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>div.right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  结果发现，即使 <code>div.left</code> 设置了右边距，这两兄弟还是重叠在了一起，如下图所示：<br>  <img src="https://i.loli.net/2018/10/15/5bc45cc291c2f.png" alt="div.left与div.right重叠"></p>
<p>  若想将两者分离开来，我们可以为 <code>div.right</code> 创建一个 BFC ，即：</p>
  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">display</span>: flow-root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  <img src="https://i.loli.net/2018/10/15/5bc45d9977a18.png" alt="div.right的BFC作用"></p>
</li>
</ul>
<p>通过以上两个例子，我们初步了解了 BFC 可以解决浮动元素对布局的影响，如浮动元素的父元素无法包住自身的问题、浮动元素与其他兄弟元素重叠的问题。此外，它还可以阻止 margin collapse（坍塌？不知道该如何翻译..看例子吧）的问题。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>first paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>second paragraphs<span class="tag">&lt;/<span class="name">p</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">2px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span> <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，在 <code>p</code> 元素和其父元素 <code>div.outer</code> 的边缘之间没有任何东西的情况下， <code>div.outer</code> 像是塌了一样顶部直接了第一个 <code>p</code> 元素的顶部齐平，同理底部。<br><img src="https://i.loli.net/2018/10/15/5bc46f41cdb3b.png" alt="margin collapse"></p>
<p>如果我们为 <code>div.outer</code> 创建 BFC ，那么就可以解决这个问题：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">display</span>: flow-root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/10/15/5bc47139ebc22.png" alt="创建BFC解决margin collapse问题"></p>
<p>细心的同学可以发现，尽管 <code>div.outer</code> 被撑起来了，但相邻的两个 <code>p</code> 元素还是发生了 margin 的重叠。这就是 BFC 的布局规则之一：同一 BFC 内的两个相邻块元素上下 margin 会重合。若想解决这个问题，只需在其中一个 <code>p</code> 元素外创建一个 BFC 包裹器即可：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>first paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>second paragraphs<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">display</span>: flow-root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">2px</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span> <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flow-root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/10/15/5bc47493e810f.png" alt="BFC中的BFC"></p>
<h2 id="创建-BFC-的方法"><a href="#创建-BFC-的方法" class="headerlink" title="创建 BFC 的方法"></a>创建 BFC 的方法</h2><p>在上面的所有例子中，我都使用 <strong><code>display: flow-root;</code></strong> 来创建 BFC ，当然还有其他的方法，例如：</p>
<ul>
<li>根元素</li>
<li><code>float</code> 属性不为 <code>none</code></li>
<li><code>overflow</code> 属性不为 <code>visible</code> 的块元素</li>
<li><code>position: absolute;</code> 或 <code>position: fixed;</code></li>
<li><code>display: flex;</code> 或 <code>display: inline-flex;</code></li>
<li><code>display: grid;</code> 或 <code>display: inline-grid;</code></li>
<li><code>display: inline-block;</code>, <code>display: table-cell;</code> 或 <code>display: table-caption;</code></li>
<li><code>column-span: all;</code></li>
<li>… <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">view more on MDN</a></li>
</ul>
<p>这些大法虽好，但很容易产生副作用。例如，如果我们使用 <code>overflow: auto;</code> 来创建一个 BFC ，在某些情况下，你可能会发现有一个多余显示的滚动条或者像我们上述例子中的 <code>outline</code> 会被剪切掉。而 <a target="_blank" rel="noopener" href="https://drafts.csswg.org/css-display/#valdef-display-flow-root"><em><strong>flow-root</strong></em></a> 是 CSS2 中专门设计为创建 BFC 的属性，它不会产生多余的副作用，所以建议使用这个属性来代替其他方法。</p>
<h2 id="不使用-BFC-清除浮动（题外扩展）"><a href="#不使用-BFC-清除浮动（题外扩展）" class="headerlink" title="不使用 BFC 清除浮动（题外扩展）"></a>不使用 BFC 清除浮动（题外扩展）</h2><p>若要清除浮动，我们可以使用 <a target="_blank" rel="noopener" href="https://css-tricks.com/snippets/css/clear-fix/">clearfix hack</a> ，只需将 <code>clearfix</code> 加到浮动元素的父元素的 <code>class</code> 属性中即可，而不一定非得创建 BFC 来达到清除浮动的效果。例如例一可以通过以下方式达到同样的效果：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent clearfix&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<p>本文完。</p>
<p>若文中有错误还请指正与包涵！</p>
<p>原文链接：<a href="https://caijialinxx.github.io/2018/10/15/block-formatting-context/">https://caijialinxx.github.io/2018/10/15/block-formatting-context/</a></p>
<p>转载请注明出处。</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.smashingmagazine.com/2017/12/understanding-css-layout-block-formatting-context/">Understanding CSS Layout And The Block Formatting Context</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">块格式化上下文 - Web开发者指南 | MDN</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html">前端精选文摘：BFC 神奇背后的原理</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://caijialinxx.github.io/2018/10/15/block-formatting-context/" data-id="cm2uc0mbj0001pggp05b3gvwt" data-title="BFC（块格式化上下文）的理解及其应用" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Notes/" rel="tag">Notes</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-http-request-and-response" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/09/http-request-and-response/" class="article-date">
  <time class="dt-published" datetime="2018-09-09T14:02:04.000Z" itemprop="datePublished">2018-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/09/http-request-and-response/">HTTP 的请求和响应</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>HTTP 协议是用来指导服务器和浏览器之间如何进行沟通的，一般来说端口默认是 <code>80</code> 。浏览器通过向服务器发送 HTTP 请求，来请求服务器中的资源。服务器根据这个请求，返回相应的响应。最后浏览器下载这个响应的实体内容。</p>
<h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><p>根据 <a target="_blank" rel="noopener" href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html">RFC 2616 的第五章 Request</a> ，一个请求基本包括请求行、请求头、 CRLF 至少这三部分内容，有时还有第四部分请求实体。<br><img src="https://i.loli.net/2018/10/09/5bbc667c2232a.png" alt="RFC 2616规范中HTTP请求的结构"></p>
<p>例如，我们使用下列命令向 <code>https://www.baidu.com</code> 发送 POST 请求（<a target="_blank" rel="noopener" href="https://explainshell.com/explain?cmd=curl+-X+POST+-d+%27%7B%22name%22:%22caijialinxx%22%7D%27+-H+%27Content-Type:+application/json%27+-s+-v+https://www.baidu.com">点击查看命令的解释</a>），可以看到它的请求报文如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d &#x27;&#123;&quot;name&quot;:&quot;caijialinxx&quot;&#125;&#x27; -H &#x27;Content-Type: application/json&#x27; -s -v https://www.baidu.com</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/10/09/5bbc72d1e70f7.png" alt="向 https://www.baidu.com 发送POST请求的请求报文"></p>
<ul>
<li>第一部分即为请求行，分别包括 <code>请求方法</code> 、 <code>请求URI</code> 、 <code>HTTP版本</code> ，它们之间使用英文空格 <code>SP</code> 分隔，此外，最后是一个换行符 <code>CRLF</code> 。</li>
<li>第二部分是以 <code>key: value</code> 形式组成的请求头。其中包括 request-header （如 <code>Host</code> <code>User-Agent</code> <code>Accept</code>）和 entity-header （如 <code>Content-Type</code> <code>Content-Length</code>）。每一对 <code>key: value</code> 请求头后也都有一个 <code>CRLF</code> 。</li>
<li>第三部分是固定不变的单独一行 <code>CRLF</code> ，用于分隔第二部分和第四部分。</li>
<li>第四部分是发送请求时带上的请求实体，即 <code>&#123;&quot;name&quot;:&quot;caijialinxx&quot;&#125;</code> 。命令行在第二部分中添加的 <code>Content-Type: application/json</code> 请求头，标示着第四部分是 JSON 格式的数据。</li>
</ul>
<p>我们发送请求的方法有以下几种：</p>
<ul>
<li><strong>GET</strong><br>GET 方法是 HTTP 请求中最常用的方法，通常用于请求服务器中的某个资源。此方法应只用来获取数据。</li>
<li>HEAD<br>HEAD 方法与 GET 方法类似，但是服务器在响应中只返回头部，而不返回响应实体。</li>
<li><strong>POST</strong><br>此方法最初是用来向服务器输入数据的。实际上经常与 HTML 表单结合使用，表单被提交时，数据通常被附加到请求实体中发送给服务器。</li>
<li><strong>PUT</strong><br>此方法让服务器用请求的实体部分来创建一个由请求中的 URL 命名的新文档，如果这个 URL 已存在，那么此次请求的主体会替代原有的主体。</li>
<li><strong>PATCH</strong><br>用于请求服务器修改指定资源的某个部分。</li>
<li><strong>DELETE</strong><br>向服务器请求删除指定 URL 对应的资源。</li>
<li>OPTIONS<br>请求 Web 服务器告知其支持的各种功能，如支持的方法或对请求某些资源支持的方法。</li>
<li>CONNECT<br>建立一个到由目标资源标识的服务器的隧道。</li>
<li>TRACE<br>沿着到目标资源的路径执行一个消息环回测试。</li>
</ul>
<h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><p>根据 <a target="_blank" rel="noopener" href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6">RFC 2616 的第六章 Response</a> ，一个响应包括状态行、响应头、 CRLF 和响应实体。<br><img src="https://i.loli.net/2018/10/09/5bbc81ec9067c.png" alt="RFC 2616规范中HTTP响应的结构"></p>
<p>在上一部分中（<a href="#HTTP%E8%AF%B7%E6%B1%82">HTTP 请求</a>），我们向 <code>https://www.baidu.com</code> 发送了一个 POST 请求，它紧接着返回了响应给我们，让我们来看看它的响应报文：<br><img src="https://i.loli.net/2018/10/09/5bbc84836492c.png" alt="服务器返回的响应报文"></p>
<ul>
<li>第一部分即为状态行，分别包括 <code>HTTP版本</code> 、 <code>状态码</code> 、 <code>状态解释</code> ，它们之间使用英文空格 <code>SP</code> 分隔，此外，最后是一个换行符 <code>CRLF</code> 。在此报文中我们可以看到状态码是 <code>302</code> ，表示页面暂时被另一个 URI 所替代，但客户端在未来的请求中仍应使用当前请求的 URI 。</li>
<li>第二部分是以 <code>key: value</code> 形式组成的响应头。其中包括 general-header (<code>Connection</code> , <code>Date</code>) 、 response-header (<code>ETag</code> , <code>Server</code>) 和 entity-header (<code>Content-Type</code> , <code>Content-Length</code>) 。每一对 <code>key: value</code> 请求头后也都有一个 <code>CRLF</code> 。</li>
<li>第三部分是固定不变的单独一行 <code>CRLF</code> ，同请求报文的第三部分。</li>
<li>第四部分是响应实体。在此报文第二部分中我们可以看到 <code>Content-Type: text/html</code> 响应头，表明第四部分是一个 HTML 文档，它有 3824 字节长度的数据。</li>
</ul>
<p>关于状态码的详解，请参考我的另一篇文章 <a href="https://caijialinxx.github.io/2018/06/27/http-status-code/">一些常见的 HTTP 状态码</a> 。</p>
<h2 id="如何使用开发者工具查看报文"><a href="#如何使用开发者工具查看报文" class="headerlink" title="如何使用开发者工具查看报文"></a>如何使用开发者工具查看报文</h2><p>作为一个前端开发人员，学会用开发者工具分析请求是一件很有帮助且不费时间的事情。下面，我将举例如何在 Chrome 中利用开发者工具查看请求报文和响应报文：</p>
<ol>
<li><p>按下 <kbd>F12</kbd> 即可打开开发者工具。</p>
</li>
<li><p>点击 Network ，当访问一个网页时，这里将会出现很多请求结果。我以阮一峰老师的个人网站为例，在地址栏中输入 <code>www.ruanyifeng.com</code> ，然后可以看到如下请求结果：<br><img src="https://i.loli.net/2018/10/09/5bbcc122db1e4.png" alt="在Chrome中访问www.ruanyifeng.com"></p>
</li>
<li><p>我们点开第一个 <code>www.ruanyifeng.com</code> ，点击 Request Header 中的 view source，这才是我们该看的格式。于是它的请求报文如下：<br><img src="https://i.loli.net/2018/10/09/5bbcc11eb4bde.png" alt="www.ruanyifeng.com的请求报文"></p>
<ul>
<li>浏览器使用 <code>GET</code> 方法向 <code>http://www.ruanyifeng.com</code> 发送一个请求，并告诉服务器它接受的响应实体类型、 Cookie 等请求头信息。</li>
</ul>
</li>
<li><p>然后同样的，点开 Response Header 中的 view source ，看到服务器发回的响应报文如下所示：<br><img src="https://i.loli.net/2018/10/09/5bbcc11eea954.png" alt="www.ruanyifeng.com的响应报文"></p>
<ul>
<li>服务器返回状态码 <code>302</code> ，告诉我们这个域名被响应头 <code>Location</code> 指向的 URI 所暂时替代，并自动完成了重定向，于是得到了第二个请求结果（箭头指向的红框）。</li>
</ul>
</li>
<li><p>查看重定向的请求结果：<br><img src="https://i.loli.net/2018/10/09/5bbcc43290425.png" alt="home.html的报文"></p>
<ul>
<li>重定向使得浏览器重新向服务器请求 <code>http://www.ruanyifeng.com/home.html</code> 这个资源，在 Response Headers 中我们可以看到此次请求成功（状态码为 <code>200</code> ），并且返回的响应实体是一个 HTML 文档，也就是我们看到的这个网页，一共有 4346 字节的内容。这个网页最后一次更新是在格林尼治的 2018-5-24 星期四 05:56:54 等信息。</li>
</ul>
</li>
</ol>
<p>现在应该知道要如何利用开发者工具查看我们的网络请求了吧~ 好处你用过就知道~ 当然开发者工具还不只有这些功能，在这里我就不做深入研究。</p>
<hr>
<p>天色已晚，本文完。</p>
<p>若文中有错误还请指正与包涵！</p>
<p>原文链接：<a href="https://caijialinxx.github.io/2018/09/09/http-request-and-response/">https://caijialinxx.github.io/2018/09/09/http-request-and-response/</a></p>
<p>转载请注明出处。</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">HTTP 请求方法</a> —— MDN</li>
<li><a target="_blank" rel="noopener" href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5">HTTP 协议之请求</a></li>
<li><a target="_blank" rel="noopener" href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6">HTTP 协议之响应</a></li>
<li><a target="_blank" rel="noopener" href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10">HTTP 协议之状态码</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://caijialinxx.github.io/2018/09/09/http-request-and-response/" data-id="cm2uc0mbz000vpggp6ec56fzk" data-title="HTTP 的请求和响应" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Notes/" rel="tag">Notes</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-seo-in-front-end" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/07/30/seo-in-front-end/" class="article-date">
  <time class="dt-published" datetime="2018-07-30T09:17:48.000Z" itemprop="datePublished">2018-07-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/07/30/seo-in-front-end/">前端搜索引擎优化（SEO）的技巧</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>我们常常可以看到一些面试题中有问【 HTML 语义化的好处是什么】，很多人都可以溜溜地说其中一个好处就是【有利于 SEO 】。那么，什么是 SEO ，大家真的都清楚吗？</p>
<h2 id="搜索引擎优化（SEO）"><a href="#搜索引擎优化（SEO）" class="headerlink" title="搜索引擎优化（SEO）"></a>搜索引擎优化（SEO）</h2><p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%90%9C%E5%B0%8B%E5%BC%95%E6%93%8E%E6%9C%80%E4%BD%B3%E5%8C%96">搜索引擎优化</a>（英语： Search Engine Optimization ，缩写为 SEO ），根据维基百科的解释是：</p>
<blockquote>
<p>它是一种透过了解搜索引擎的运作规则来调整网站，以及提高目的网站在有关搜索引擎内排名的方式。由于不少研究发现，搜索引擎的用户往往只会留意搜索结果最前面的几个条目，所以不少网站都希望透过各种形式来影响搜索引擎的排序，让自己的网站可以有优秀的搜索排名。当中尤以各种依靠广告维生的网站为甚。</p>
</blockquote>
<p>也就是说，通过搜索引擎优化，我们的网站可以在搜索结果的排名中靠前。</p>
<p>那么，作为一个前端，我们该如何为搜索引擎优化做出一点贡献呢？</p>
<h2 id="优化的技巧"><a href="#优化的技巧" class="headerlink" title="优化的技巧"></a>优化的技巧</h2><p>在学习如何优化之前，我们最好了解一下当我们在“百度一下”或者“ Google 搜索”时，搜索引擎都做了一些什么。</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/BNHR6IQJGZs?rel=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>

<p>这个视频 <a target="_blank" rel="noopener" href="https://youtu.be/BNHR6IQJGZs">How Search Works</a> 解释了搜索引擎是如何工作的。需要科学上网才能看得到，当然在这里我也会总结一下这个视频的大意：</p>
<p>当搜索进行时，它会从“蜘蛛”事先抓取到的大量有关联性的索引中，搜索所有包含用户输入的关键字的网页，然后根据算法给出每个网页一个总评分，再根据评分的高低给用户返回搜索结果。而这些包含关键字的内容，可以是文章标题、描述、关键字、内容、甚至是链接等。</p>
<p>由上可以得知，要想优化，我们可以从这些方面入手。</p>
<h3 id="创建唯一且准确的网页标题"><a href="#创建唯一且准确的网页标题" class="headerlink" title="创建唯一且准确的网页标题 &lt;title&gt;"></a>创建唯一且准确的网页标题 <code>&lt;title&gt;</code></h3><p><code>&lt;title&gt;</code> 标记可告诉用户和搜索引擎特定网页的主题是什么。它应放置在 HTML 文档的 <code>&lt;head&gt;</code> 元素中。我们应该为网站上的每个网页创建一个唯一标题，并且尽量避免与网页内容无关或使用默认或模糊的标题。如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 正确示范 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>前端搜索引擎优化的技巧<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 错误示范 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>我的文档<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-meta-description"><a href="#使用-meta-description" class="headerlink" title="使用 meta description"></a>使用 <code>meta description</code></h3><p>我们可以使用 <code>meta description</code> 标签来准确概括总结网页内容。我们应避免内容中出现关键词的堆砌、描述过长、描述过于笼统简单，如直接拷贝关键词或正文内容、或“这是一个网页”这种没有实际性意义的描述等现象。正确示范如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&#x27;description&#x27;</span> <span class="attr">content</span>=<span class="string">&#x27;本文主要介绍搜索引擎优化（SEO）的技巧，如使用title、description、keywords、语义化标签、img的alt属性等。&#x27;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-meta-keywords"><a href="#使用-meta-keywords" class="headerlink" title="使用 meta keywords"></a>使用 <code>meta keywords</code></h3><p>我们可以使用 <code>meta keywords</code> 来提炼网页重要关键字，如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&#x27;keywords&#x27;</span> <span class="attr">content</span>=<span class="string">&#x27;SEO,搜索引擎优化,网页排名优化&#x27;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但有些建站者为了网页能有较好的排名，故意在这个标签中大量堆砌关键字，也就是所谓的“<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh/%E6%90%9C%E5%B0%8B%E5%BC%95%E6%93%8E%E6%9C%80%E4%BD%B3%E5%8C%96#%E9%BB%91%E5%B8%BD%E6%96%B9%E6%B3%95">黑帽方法</a>”之一。于是搜索引擎为了为用户提供优质的搜索结果，优化了它们的爬取算法——当出现大量关键字堆砌时，搜索引擎可能会降低这个网站的排名甚至将其列入黑名单。所以我们需慎用或者不用这个标签，使用的话一般设置3-4个关键词即可。</p>
<p>注意： <code>&lt;title&gt;</code> 、 <code>meta description</code> 和 <code>meta keywords</code> 三者的权重依次减小，我们要想网页有好的排名，必须合理使用这三个标签。</p>
<h3 id="使用语义化元素"><a href="#使用语义化元素" class="headerlink" title="使用语义化元素"></a>使用语义化元素</h3><p>在合适的位置使用合适的元素表达合适的内容，让用户和“蜘蛛”能一目了然文档结构。例如使用 <code>&lt;h1&gt;</code> 可以让“蜘蛛”知道这是很重要的内容。然而，值得注意的是，例如在想要表达强调时，我们不应该滥用标题元素或者 <code>&lt;b&gt;</code> 、 <code>&lt;i&gt;</code> 这种没有实际意义的标签，换而可以使用 <code>&lt;em&gt;</code> 或 <code>&lt;strong&gt;</code> 来表示强调。此外， <code>&lt;h1&gt;</code> 的权重比 <code>&lt;h2&gt;</code> 的大，我们不应该为了增大权重而去滥用 <code>&lt;h1&gt;</code> ，一般来说 <code>&lt;h1&gt;</code> 用于正文的标题。</p>
<h3 id="利用-中的-alt-属性"><a href="#利用-中的-alt-属性" class="headerlink" title="利用 &lt;img&gt; 中的 alt 属性"></a>利用 <code>&lt;img&gt;</code> 中的 <code>alt</code> 属性</h3><p><code>alt</code> 属性可以在图片未成功显示时候，使用文本来代替图片的呈现，使“蜘蛛”可以抓取到这个信息。此外它还可以解决浏览器禁用图像或屏幕阅读器解析等问题。</p>
<h3 id="设置-rel-nofollow-忽略跟踪"><a href="#设置-rel-nofollow-忽略跟踪" class="headerlink" title="设置 rel=&#39;nofollow&#39; 忽略跟踪"></a>设置 <code>rel=&#39;nofollow&#39;</code> 忽略跟踪</h3><p>如果某个 <code>&lt;a&gt;</code> 的链接不需要跟踪，那么添加 <code>rel=&#39;nofollow&#39;</code> 即可通知“蜘蛛”忽略跟踪。因为“蜘蛛”分配到每个页面的权重是一定的，为了集中网页权重并将权重分给其他必要的链接，为不必跟踪的链接添加这个属性就显得很必要了。</p>
<h3 id="提高加载速度"><a href="#提高加载速度" class="headerlink" title="提高加载速度"></a>提高加载速度</h3><p>我们应尽量让结构（HTML）、表现（CSS）及行为（JavaScript）三者分离。如果在一个 HTML 页面中，编写大量的 CSS 样式或脚本，会拖慢其加载速度，此外，如果不为 <code>&lt;img&gt;</code> 定义宽高，那么会引起页面重新渲染，同样也会影响加载速度。一旦加载超时，“蜘蛛”就会放弃爬取。</p>
<h3 id="扁平化网站结构"><a href="#扁平化网站结构" class="headerlink" title="扁平化网站结构"></a>扁平化网站结构</h3><p>一般来说，一个网站的结构层次越少，越有利于“蜘蛛”的爬取。所以目录结构一般不多于 3 级，否则“蜘蛛”很容易不愿意继续往下爬。就像用户在操作一个网页一样，层级大于 3 就很影响用户体验了，“蜘蛛”就是模仿用户的心理。</p>
<h3 id="合理安排重要内容的位置"><a href="#合理安排重要内容的位置" class="headerlink" title="合理安排重要内容的位置"></a>合理安排重要内容的位置</h3><p>我们应该将含重要内容的 HTML 代码放在最前面，因为“蜘蛛”爬取 HTML 的顺序是从上到下，有的搜索引擎对抓取长度有限制，所以要保证重要内容被优先爬取。并且，重要内容不应该由 JavaScript 输出，因为“蜘蛛”没有办法读取 JavaScript ，同时也要少用 iframe ，因为“蜘蛛”一般不会去读取它里面的内容。</p>
<hr>
<p>本文完。</p>
<p>若文中有错误还请指正与包涵！</p>
<p>原文链接：<a href="https://caijialinxx.github.io/2018/07/30/seo-in-front-end/">https://caijialinxx.github.io/2018/07/30/seo-in-front-end/</a></p>
<p>转载请注明出处。</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%90%9C%E5%B0%8B%E5%BC%95%E6%93%8E%E6%9C%80%E4%BD%B3%E5%8C%96">搜索引擎优化</a> —— 维基百科</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/EnSnail/p/5671345.html">前端SEO技巧</a></li>
<li><a target="_blank" rel="noopener" href="https://support.google.com/webmasters/answer/7451184?hl=zh-Hans">搜索引擎优化 (SEO) 新手指南</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://caijialinxx.github.io/2018/07/30/seo-in-front-end/" data-id="cm2uc0mc3001apggp34vaf3rw" data-title="前端搜索引擎优化（SEO）的技巧" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Notes/" rel="tag">Notes</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SEO/" rel="tag">SEO</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-deploy-on-heroku" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/07/25/deploy-on-heroku/" class="article-date">
  <time class="dt-published" datetime="2018-07-25T12:13:04.000Z" itemprop="datePublished">2018-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/07/25/deploy-on-heroku/">Windows 系统下的 Heroku 部署</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本篇教程是在 Windows 的 Node.js 环境下使用的~ 如果需要其他语言或平台，请戳 <a target="_blank" rel="noopener" href="https://devcenter.heroku.com/start">这里</a> 看看有没有你要的。</p>
<p>这是官网的 <a target="_blank" rel="noopener" href="https://devcenter.heroku.com/articles/getting-started-with-nodejs">教程(Node.js)</a> ，全英的，英文阅读能力 OK 的同学可以戳戳，但是！竟然来都来了，那就看一下我写的吧~ 欢迎各位同学指正！</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>第一步肯定是安装。这里没有多余的文案，直接甩安装地址给你，请各位同学根据自己的系统选择 <a target="_blank" rel="noopener" href="https://cli-assets.heroku.com/heroku-x64.exe">64位</a> 或 <a target="_blank" rel="noopener" href="https://cli-assets.heroku.com/heroku-x86.exe">32位</a> 的。</p>
<p>假设你阅读本篇文章的时候已安装了 Node v8+ 、 对应版本的 npm 和 git 。接下来让我们继续往下走。</p>
<h1 id="本地创建-Heroku-账户"><a href="#本地创建-Heroku-账户" class="headerlink" title="本地创建 Heroku 账户"></a>本地创建 Heroku 账户</h1><h2 id="在-Windows-的命令提示符上操作"><a href="#在-Windows-的命令提示符上操作" class="headerlink" title="在 Windows 的命令提示符上操作"></a>在 Windows 的命令提示符上操作</h2><p>安装完成之后，你可以直接使用 Windows 的命令提示符（<kbd>Win</kbd> + <kbd>R</kbd>），输入 <code>heroku login</code> ，即可创建你的 Heroku 账户。<br><img src="https://i.loli.net/2018/07/20/5b517a5c96035.png" alt="在命令提示符使用heroku.png"></p>
<p>但是， Windows 的命令行这么难用（且丑），用习惯 <a target="_blank" rel="noopener" href="https://gitforwindows.org/">Git Bash</a> 的我简直没法忍！我是在 Git Bash 上操作的，所以下面介绍一下 Heroku 在 Git Bash 上的使用（本节的命令都可以在命令提示符里使用）。</p>
<h2 id="在-Git-Bash-上操作"><a href="#在-Git-Bash-上操作" class="headerlink" title="在 Git Bash 上操作"></a>在 Git Bash 上操作</h2><p>我在 Git Bash 执行 heroku 的命令时，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ heroku login</span><br><span class="line">bash: heroku: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>
<p>发现它竟然给我错误提示说找不到该命令！后来我找到它的安装路径（G:\heroku\bin），并尝试运行 <code>/g/heroku/bin/heroku -v</code> ，嘿嘿，成了！</p>
<p><img src="https://i.loli.net/2018/07/20/5b518195054af.png" alt="在Git Bash中使用heroku失败.png"></p>
<p>原来是我没有给 Git Bash 添加环境变量的关系，那么二话不说立马为它添加环境变量吧~ 步骤如下：</p>
<ol>
<li>如果你没有 <code>.bashrc</code> 这个文件，就先创建再编辑。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> ~/.bashrc &amp;&amp; vi ~/.bashrc</span><br></pre></td></tr></table></figure></li>
<li>在文件中添加 heroku.cmd 的路径作为其环境变量后（如下所示），保存并退出 <code>:wq</code> 即可。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;/g/heroku/bin/:$PATH&quot;</span><br></pre></td></tr></table></figure>
此时，我们就可以在 Git Bash 上愉快地使用 <code>heroku [COMMAND]</code> 了~</li>
</ol>
<p><img src="https://i.loli.net/2018/08/25/5b8127ec9255c.png" alt="在Git Bash中成功使用heroku.png"></p>
<h1 id="部署项目到-Heroku"><a href="#部署项目到-Heroku" class="headerlink" title="部署项目到 Heroku"></a>部署项目到 Heroku</h1><p>首先，我们直接拿 Heroku 提供的 Demo 来学习如何部署。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/heroku/node-js-getting-started.git heroku-demo</span><br><span class="line"></span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>这样我们就在 <code>heroku-demo</code> 目录下有了一个 Node.js 的项目，然后我们就可以将项目部署到 Heroku 了。</p>
<ol>
<li><p>在 Heroku 上创建一个应用程序，准备让 Heroku 接收我们的代码。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ heroku create</span><br><span class="line">Creating app... <span class="keyword">done</span>, tranquil-crag-99140</span><br><span class="line">https://tranquil-crag-99140.herokuapp.com/ | https://git.heroku.com/tranquil-crag-99140.git</span><br></pre></td></tr></table></figure>
<p> 这时， Heroku 给我们返回这个 app 的编号 <code>tranquil-crag-99140</code> 及地址 <code>https://tranquil-crag-99140.herokuapp.com/</code> ，即可说明我们已创建成功。</p>
<p> <img src="https://i.loli.net/2018/07/20/5b519199a8a64.png" alt="c93fe62e0ba6d6daa7b3416566929c9.png"></p>
</li>
<li><p>接下来我们终于可以部署代码到 Heroku 了。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ git push heroku master</span><br><span class="line">Counting objects: 490, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (368/368), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (490/490), 230.24 KiB | 20.93 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 490 (delta 87), reused 490 (delta 87)</span><br><span class="line">remote: Compressing <span class="built_in">source</span> files... <span class="keyword">done</span>.</span><br><span class="line">remote: Building <span class="built_in">source</span>:</span><br><span class="line">remote:</span><br><span class="line">remote: -----&gt; Node.js app detected</span><br><span class="line">remote:</span><br><span class="line">remote: -----&gt; Creating runtime environment</span><br><span class="line">...</span><br><span class="line">remote: -----&gt; Installing binaries</span><br><span class="line">...</span><br><span class="line">remote: -----&gt; Restoring cache</span><br><span class="line">...</span><br><span class="line">remote: -----&gt; Building dependencies</span><br><span class="line">...</span><br><span class="line">remote: -----&gt; Caching build</span><br><span class="line">...</span><br><span class="line">remote: -----&gt; Pruning devDependencies</span><br><span class="line">...</span><br><span class="line">remote: -----&gt; Build succeeded!</span><br><span class="line">remote: -----&gt; Discovering process types</span><br><span class="line">...</span><br><span class="line">remote: -----&gt; Compressing...</span><br><span class="line">remote:        Done: 18.9M</span><br><span class="line">remote: -----&gt; Launching...</span><br><span class="line">remote:        Released v3</span><br><span class="line">remote:        https://tranquil-crag-99140.herokuapp.com/ deployed to Heroku</span><br><span class="line">remote:</span><br><span class="line">remote: Verifying deploy... <span class="keyword">done</span>.</span><br><span class="line">To https://git.heroku.com/tranquil-crag-99140.git</span><br><span class="line">* [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure>
<p> 说明太长了所以我只截取了一些重要的过程，最后的 <code>remote: Verifying deploy... done.</code> 说明项目已被成功部署，我们刷新 <code>https://tranquil-crag-99140.herokuapp.com/</code> ，即可看到下图所示的页面。</p>
<p> <img src="https://i.loli.net/2018/07/20/5b51931843694.png" alt="项目成功部署到heroku.png"><br> 当然我们也可以用 <code>heroku open</code> 来快速打开这个网页。</p>
</li>
</ol>
<p>好啦，你应该学会了吧~ 那么何不尝试做一个小项目并将其部署上去了~ 温故知新哦！</p>
<hr>
<h1 id="使用-SSH-Git-传输（扩展）"><a href="#使用-SSH-Git-传输（扩展）" class="headerlink" title="使用 SSH Git 传输（扩展）"></a>使用 SSH Git 传输（扩展）</h1><p>本节是额外补充，上节是使用默认的 HTTP Git 传输，不过 Heroku 也支持使用 SSH Git 传输。所以喜欢用 SSH Git 传输的可以了解一下~</p>
<p>要使用 SSH Git 传输，需要先配置 SSH 密钥。如果你没有生成过 SSH 密钥，那么需要先输入 <code>ssh-keygen -t rsa</code> 生成，期间有三次询问的过程（如下所示），直接三次回车即可，它将会自动取其默认值（即括号中显示的内容）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (C:\Users\ASUS-NB\.ssh\id_rsa):</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> C:\Users\ASUS-NB\.ssh\id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> C:\Users\ASUS-NB\.ssh\id_rsa.pub.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后， <code>heroku keys:add</code> 将公钥上传到 Heroku ，它会询问你是否确定上传，输入 <code>y</code> 即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ heroku keys:add</span><br><span class="line">Found an SSH public key at C:\Users\ASUS-NB\.ssh\id_rsa.pub</span><br><span class="line">Would you like to upload it to Heroku? [Y/n]: y</span><br><span class="line">Uploading C:\Users\ASUS-NB\.ssh\id_rsa.pub SSH key... <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>此时，你就可以输入 <code>heroku keys</code> 查看 Heroku 的 keys 了。下图说明我们已成功上传 SSH key。<br><img src="https://i.loli.net/2018/07/20/5b519199a598d.png" alt="查看heroku密钥.png"></p>
<p>你可以点击这里可以了解更多关于 Heroku <a target="_blank" rel="noopener" href="https://devcenter.heroku.com/articles/keys">管理 SSH 密钥</a> 的 API 。</p>
<p>SSH Git 传输跟 HTTP Git 传输，在命令上只有一小点区别。我们只需要添加 <code>--ssh-git</code> 到 <code>heroku create</code> 、 <code>heroku git:remote</code> 和 <code>heroku git:clone</code> 命令中即可。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ heroku create --ssh-git</span><br></pre></td></tr></table></figure>

<p>如果你始终使用 SSH Git 传输，那么可以为其全局配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global url.ssh://git@heroku.com/.insteadOf https://git.heroku.com/</span><br></pre></td></tr></table></figure>


<p>本文完。</p>
<p>参考资料总结：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://devcenter.heroku.com/start">Getting Started on Heroku</a></li>
<li><a target="_blank" rel="noopener" href="https://devcenter.heroku.com/articles/keys">Managing Your SSH Keys</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://caijialinxx.github.io/2018/07/25/deploy-on-heroku/" data-id="cm2uc0mbs000cpggpdsa0dxnt" data-title="Windows 系统下的 Heroku 部署" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Notes/" rel="tag">Notes</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-interview-html" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/07/17/interview-html/" class="article-date">
  <time class="dt-published" datetime="2018-07-17T08:10:45.000Z" itemprop="datePublished">2018-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/07/17/interview-html/">面试常考题之 HTML</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="HTML-语义化的理解"><a href="#HTML-语义化的理解" class="headerlink" title="HTML 语义化的理解"></a>HTML 语义化的理解</h2><blockquote>
<p>A semantic element clearly describes its meaning to both the browser and the developer.<br>一个语义化的元素能够清晰地向浏览者和开发者描述它的意义。</p>
</blockquote>
<p>常见的语义化标签有： <code>&lt;p&gt;</code> 、 <code>&lt;h1&gt;</code> 、 <code>&lt;button&gt;</code> 、 <code>&lt;article&gt;</code> 、 <code>&lt;aside&gt;</code> 、 <code>&lt;header&gt;</code> 、 <code>&lt;footer&gt;</code> 、 <code>&lt;main&gt;</code> 、 <code>&lt;nav&gt;</code> 、 <code>&lt;section&gt;</code> 等。</p>
<ul>
<li>「语义化」概念的出现<ul>
<li>最开始的 HTML 页面是由 PHP 后端写的，他们不会 CSS ，于是只能使用 table 来布局。然而 table 是用来展示表格的，这种投机取巧的使用方法严重违反了 HTML 语义化原则。</li>
<li>后来，有了会写 CSS 的前端之后，他们就使用 DIV + CSS 来实现页面布局，主要是用 <code>float</code> 和 <code>position</code> 属性。看起来好了一点，但整个页面的结构都是 DIV ，也非常的不可观。</li>
<li>随着发展，前端渐渐变得专业，为了改善这种杂乱的结构，「语义化」这一概念被提出，前端尽量使用 <code>&lt;p&gt;</code> 、 <code>&lt;h1&gt;</code> 这种有意义的标签来展示内容。此外， HTML5 为我们提供了更多的语义化标签，例如 <code>&lt;header&gt;</code> 、 <code>&lt;footer&gt;</code> 、 <code>&lt;main&gt;</code> 、 <code>&lt;nav&gt;</code> 、 <code>&lt;section&gt;</code> 等。</li>
</ul>
</li>
</ul>
<h3 id="总的来说"><a href="#总的来说" class="headerlink" title="总的来说"></a>总的来说</h3><p>  HTML 语义化就是使用有意义的标签来展示内容，例如 <code>&lt;p&gt;</code> 表示段落， <code>&lt;aside&gt;</code> 表示侧边栏， <code>&lt;nav&gt;</code> 表示导航。这使得页面结构易于阅读、方便理解，此外，还能有益于 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BC%98%E5%8C%96/3132?fromtitle=seo&fromid=102990&fr=aladdin">SEO</a> （Search Engine Optimization，搜索引擎优化）、其他设备的解析（如屏幕阅读器、盲人阅读器、移动设备）。</p>
<h2 id="meta-viewport-的原理"><a href="#meta-viewport-的原理" class="headerlink" title="meta viewport 的原理"></a>meta viewport 的原理</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&#x27;viewport&#x27;</span> <span class="attr">content</span>=<span class="string">&#x27;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&#x27;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最初，网页只会在 PC 端展现，所以页面宽度是适应大多数 PC 端的。后来，随着智能手机（iPhone 3GS）的出现，原本为 PC 端设计的网页在小屏的手机上就“胖到挤不下”，用户只能不断移动这些网页来达到浏览的目的。后来乔布斯的工程师想了一个办法：他们让手机宽度模拟成 980px ，这样页面就能缩小了，用户想要浏览某个部分只需要手动放大。<br>但是随着智能手机的普及，这种不方便用户的功能显然不够贴心。 <code>&lt;meta name=&#39;viewport&#39;&gt;</code> 的出现就是为了解决这个问题：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>width</td>
<td>[number] &#x2F; device-width</td>
<td>控制 viewport 的大小，可以指定的一个数字，如 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。</td>
</tr>
<tr>
<td>height</td>
<td>[number] &#x2F; device-height</td>
<td>和 width 相对应，指定高度。</td>
</tr>
<tr>
<td>initial-scale</td>
<td>[number]</td>
<td>初始缩放比例，也即是当页面第一次加载时的缩放比例。</td>
</tr>
<tr>
<td>maximum-scale</td>
<td>[number]</td>
<td>允许用户缩放到的最大比例。</td>
</tr>
<tr>
<td>minimum-scale</td>
<td>[number]</td>
<td>允许用户缩放到的最小比例。</td>
</tr>
<tr>
<td>user-scalable</td>
<td>yes &#x2F; no</td>
<td>用户是否可以手动缩放。</td>
</tr>
</tbody></table>
<h3 id="总的来说-1"><a href="#总的来说-1" class="headerlink" title="总的来说"></a>总的来说</h3><p>我们可以通过设置 <code>&lt;meta name=&#39;viewport&#39; content=&#39;width=device-width, initial-scale=1.0&#39;&gt;</code> 来使得页面自适应屏幕的宽度，并且不被缩小。</p>
<h2 id="canvas-的使用"><a href="#canvas-的使用" class="headerlink" title="canvas 的使用"></a>canvas 的使用</h2><p>这里有一个我自己做的项目示例 <a href="https://caijialinxx.github.io/jirengu-homework/canvas/">Canvas 画板</a>，去玩一下呗~</p>
<p>这里总结一下 <code>&lt;canvas&gt;</code> 元素中常用的 API 及用法。</p>
<p>首先我们要在 HTML 中添加一个 canvas 元素：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;canvas&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在 JavaScript 中取到这个元素，就可以执行一些操作：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 canvas 元素</span></span><br><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>)</span><br><span class="line"><span class="comment">// 「常用 API」 1. getContext() 访问绘画上下文</span></span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 「常用 API」 2. fillStyle 设置图形的填充颜色</span></span><br><span class="line">ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;orange&#x27;</span></span><br><span class="line"><span class="comment">// 「常用 API」 3. strokeStyle 设置图形的轮廓颜色</span></span><br><span class="line">ctx.<span class="property">strokeStyle</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line"><span class="comment">// 「常用 API」 4. strokeStyle 设置图形的轮廓颜色</span></span><br><span class="line">ctx.<span class="property">lineWidth</span> = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 绘制矩形 */</span></span><br><span class="line"><span class="comment">// 「常用 API」 5. fillRect(x, y, width, height) 绘制一个填充的矩形</span></span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">25</span>,<span class="number">25</span>,<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line"><span class="comment">// 「常用 API」 6. clearRect(x, y, width, height) 清除指定矩形区域，让清除部分完全透明</span></span><br><span class="line">ctx.<span class="title function_">clearRect</span>(<span class="number">45</span>,<span class="number">45</span>,<span class="number">60</span>,<span class="number">60</span>)</span><br><span class="line"><span class="comment">// 「常用 API」 7. strokeRect(x, y, width, height) 绘制一个矩形的边框</span></span><br><span class="line">ctx.<span class="title function_">strokeRect</span>(<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 绘制路径 */</span></span><br><span class="line"><span class="comment">// 「常用 API」 8. beginPath() 新建一条路径</span></span><br><span class="line">ctx.<span class="title function_">beginPath</span>()</span><br><span class="line"><span class="comment">// 「常用 API」 9. moveTo(x, y) 将笔触移动到指定的坐标x以及y上</span></span><br><span class="line">ctx.<span class="title function_">moveTo</span>(<span class="number">160</span>,<span class="number">75</span>)</span><br><span class="line"><span class="comment">// 「常用 API」 10. lineTo(x, y) 绘制一条从当前位置到指定x以及y位置的直线</span></span><br><span class="line">ctx.<span class="title function_">lineTo</span>(<span class="number">220</span>,<span class="number">125</span>)</span><br><span class="line">ctx.<span class="title function_">lineTo</span>(<span class="number">220</span>,<span class="number">25</span>)</span><br><span class="line"><span class="comment">// 「常用 API」 11. closePath() 闭合路径，不是必须的</span></span><br><span class="line">ctx.<span class="title function_">closePath</span>()</span><br><span class="line"><span class="comment">// 「常用 API」 12. stroke() 通过线条来绘制图形轮廓。如果不调用 closePath() 则 stroke() 不会自动闭合</span></span><br><span class="line">ctx.<span class="title function_">stroke</span>()</span><br><span class="line"><span class="comment">// 「常用 API」 13. fill() 填充路径的内容区域生成实心的图形。即使不调用 closePath() 所有没有闭合的形状仍会自动闭合填充</span></span><br><span class="line">ctx.<span class="title function_">fill</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 绘制圆形 */</span></span><br><span class="line">ctx.<span class="title function_">beginPath</span>()</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 「常用 API」 14. arc(x, y, radius, startAngle, endAngle, anticlockwise)</span></span><br><span class="line"><span class="comment"> *                  画一个以（x,y）为圆心， radius 为半径的圆，</span></span><br><span class="line"><span class="comment"> *                  从 startAngle 开始到 endAngle 结束，</span></span><br><span class="line"><span class="comment"> *                  按照 anticlockwise 给定的方向（默认为顺时针）来生成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ctx.<span class="title function_">arc</span>(<span class="number">300</span>, <span class="number">75</span>, <span class="number">50</span>, <span class="number">6</span>, <span class="number">2</span>*<span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">true</span>)</span><br><span class="line">ctx.<span class="title function_">fill</span>()</span><br><span class="line">ctx.<span class="title function_">stroke</span>()</span><br></pre></td></tr></table></figure>
<p>你可以查看这个小 Demo 的<a target="_blank" rel="noopener" href="http://jsbin.com/vekayejuyi/edit?js,output">演示效果</a> ，并且可以尝试改动一下。</p>
<ul>
<li>总结：<ul>
<li><strong><code>getContext()</code></strong></li>
<li><code>fillStyle</code></li>
<li><code>strokeStyle</code></li>
<li><code>beginPath()</code></li>
<li><code>closePath()</code></li>
<li><code>moveTo()</code></li>
<li><code>lineTo()</code></li>
<li><code>stroke()</code></li>
<li><code>fill()</code><br>…</li>
</ul>
</li>
</ul>
<p>你还可以学习一下 MDN 中的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial">canvas 教程</a> ，里面还有<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Drawing_text">绘制文本</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Transformations">变形</a>等很有意思的教程。</p>
<h2 id="细节常识题"><a href="#细节常识题" class="headerlink" title="细节常识题"></a>细节常识题</h2><ol>
<li>浏览器默认的字体大小<ul>
<li><strong>16px</strong></li>
</ul>
</li>
<li><code>&lt;strong&gt;</code> 和 <code>&lt;b&gt;</code> 、 <code>&lt;em&gt;</code> 和 <code>&lt;i&gt;</code> 的区别<ul>
<li><p><code>&lt;strong&gt;</code> 和 <code>&lt;b&gt;</code> 都可以使字体变粗，但前者表示强调，它可以标明重点内容，而后者没有什么实际含义。</p>
</li>
<li><p><code>&lt;em&gt;</code> 和 <code>&lt;i&gt;</code> 都可以使字体变斜体，但前者表示也是用来强调文本，经常使用在表示重要术语或引用等，而后者没有什么实际含义。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我是这个世界上<span class="tag">&lt;<span class="name">strong</span>&gt;</span>最美的<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>人。</span><br><span class="line">我想让这个字变<span class="tag">&lt;<span class="name">b</span>&gt;</span>粗<span class="tag">&lt;/<span class="name">b</span>&gt;</span>。</span><br><span class="line">我喜欢 <span class="tag">&lt;<span class="name">em</span>&gt;</span>Professional Javascript for Web Developer 3rd<span class="tag">&lt;/<span class="name">em</span>&gt;</span> 这本书。</span><br><span class="line">我想让这个字变<span class="tag">&lt;<span class="name">i</span>&gt;</span>歪<span class="tag">&lt;/<span class="name">i</span>&gt;</span>。</span><br></pre></td></tr></table></figure>
<p>我是这个世界上<strong>最美的</strong>人。<br>我想让这个字变<b>粗</b>。<br>我喜欢 <em>Professional Javascript for Web Developer 3rd</em> 这本书。<br>我想让这个字变<i>歪</i>。</p>
</li>
<li><p>我们应尽量遵循 HTML 语义化，表示重要的内容时使用 <code>&lt;strong&gt;</code> 或 <code>&lt;em&gt;</code> ，避免单纯为了让字体变粗而使用 <code>&lt;b&gt;</code> ，或者单纯为了让字体变斜而使用 <code>&lt;i&gt;</code> 的情况，这些样式应该由 CSS 去控制。</p>
</li>
<li><p>这里有一个来自 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/strong#Usage_notes">MDN</a> 的比较，可以参考一下。</p>
</li>
</ul>
</li>
<li><code>href</code> 和 <code>src</code> 的区别<ul>
<li><code>href</code> 是 Hypertext Reference 的缩写，表示超文本引用，用来建立文档和外部资源之间的联系。常用的有 <code>&lt;a&gt;</code> 和 <code>&lt;link&gt;</code> 标签。</li>
<li><code>src</code> 是 source 的缩写，是页面种必不可少的一部分，其指向的内容会嵌入到文档中当前元素所在的位置。浏览器在下载、解析这个元素的时候会暂停页面的加载和处理。常用的有 <code>&lt;script&gt;</code> 、 <code>&lt;img&gt;</code> 和 <code>&lt;iframe&gt;</code> 标签。</li>
<li>总的来说就是 <code>src</code> 用于替换当前元素，而 <code>href</code> 用于建立文档与引用资源的联系。</li>
</ul>
</li>
<li><code>readonly</code> 和 <code>disabled</code> 的区别<ul>
<li><code>readonly</code> 表示这个控件是<strong>只读</strong>的，无法在页面上修改，但可以通过 JavaScript 修改。在提交表单时此控件的值会被传出去。</li>
<li><code>disabled</code> 表示这个控件是<strong>被禁用</strong>的，同样无法在页面上修改内容（可以通过 JS 修改），在提交表单时该控件的内容不会被提交。</li>
</ul>
</li>
<li>块级元素与行内元素的区别<ul>
<li>默认情况下，块级元素会另起一行，而行内元素不会以新行开始。</li>
<li>块级元素可以设置宽高，而行内元素的宽高由内容物决定。</li>
<li>块级元素里面可以有行内元素或其他块级元素，而行内元素只能包含数据或其他行内元素。</li>
<li>块级元素有 <code>&lt;div&gt;</code> 、 <code>&lt;p&gt;</code> 、 <code>&lt;ul&gt;</code> 、 <code>&lt;header&gt;</code> 、 <code>&lt;form&gt;</code> 等，而行内元素有 <code>&lt;span&gt;</code> 、 <code>&lt;select&gt;</code> 、 <code>&lt;strong&gt;</code> 、 <code>&lt;input&gt;</code> 、 <code>&lt;button&gt;</code> 、 <code>&lt;textarea&gt;</code> 等。</li>
</ul>
</li>
<li>doctype 的作用<ul>
<li>声明文档类型，告诉浏览器要用什么文档类型规范来解析这个文档。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://caijialinxx.github.io/2018/07/17/interview-html/" data-id="cm2uc0mc8001qpggpf8lbc3rs" data-title="面试常考题之 HTML" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-cookie-session-webStorage" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/07/16/cookie-session-webStorage/" class="article-date">
  <time class="dt-published" datetime="2018-07-16T09:19:17.000Z" itemprop="datePublished">2018-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/07/16/cookie-session-webStorage/">Cookie, Session, LocalStorage &amp; SessionStorage</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>由于刚刚写过一篇介绍 <a href="https://caijialinxx.github.io/2018/07/12/cookie/">Cookie</a> 的博客，所以我在这里不打算再次介绍多一遍，直接总结如下：</p>
<ol>
<li>Cookie 是一段由服务器发送给浏览器并保存到本地的一段数据，大小一般为 4KB 。</li>
<li>它存储着用户的一些信息，在浏览器再次访问同一个 URL 时会将这段 Cookie 附加到 HTTP 请求中发送给服务器。因此，这会增加流量的消耗。</li>
<li>一般在浏览器关闭（会话结束）时就被删除，但也可以通过 <code>Expire</code> 或 <code>Max-Age</code> 来设置过期时间。</li>
<li>浏览器可以通过 <code>document.cookie</code> 读写 Cookie ，若要阻止此行为，可以在 <code>Set-Cookie</code> 头中添加 <code>HttpOnly</code> 标记。</li>
</ol>
<p>详细的还请移步到 <a href="https://caijialinxx.github.io/2018/07/12/cookie/">HTTP 牌的 Cookie</a> 参阅。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session 的实质是存储在服务器里的一小块内存，一般来说是基于 Cookie 实现的。实现过程举例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 1. 当第一次使用 Session 时，服务器要创建一个 SessionID</span></span><br><span class="line"><span class="comment"> *    来作为 Session 中存放用户信息的唯一标识</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> session = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> sessionID = <span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toString</span>().<span class="title function_">slice</span>(<span class="number">2</span>)       <span class="comment">// 假设为 &#x27;1234567890&#x27;</span></span><br><span class="line">session[sessionID] = 用户信息       <span class="comment">// 此时服务器中已存含有用户信息的 SessionID 对应的内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 服务器通过 Cookie 给用户返回一个 SessionID */</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Set-Cookie&#x27;</span>, sessionID)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 3. 当用户访问同一个 URL 时，向服务器发送这个内容为其 SessionID 的 Cookie 头 */</span><br><span class="line">Request Header</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 580</span><br><span class="line">Cookie: 1234567890</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 4. 服务器读取 Cookie 中的 SessionID ，</span></span><br><span class="line"><span class="comment"> *    然后去 Session 中读取对应的内存，最终得到用户信息。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (request.<span class="property">headers</span>.<span class="property">cookie</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> sessionID = request.<span class="property">headers</span>.<span class="property">cookie</span></span><br><span class="line">  <span class="keyword">let</span> userInfo = session[sessionID]               <span class="comment">// 读取用户信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是， SessionID 是随机生成的。</p>
<h2 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h2><p><code>window.localStorage</code> 是 HTML5 新增的一个 API ，它遵循同源政策，属于本地存储。它有以下特点：</p>
<ol>
<li>大小一般为 5MB ，永久有效；</li>
<li>本地存储和读取，不会被附加到 HTTP 请求中。</li>
</ol>
<p><code>window.localStorage</code> 的使用如下例所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据到 LocalStorage</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>)           <span class="comment">// &#123;&quot;key&quot;: &quot;value&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 LocalStorage 获取数据</span></span><br><span class="line"><span class="keyword">let</span> key = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>)          <span class="comment">// &quot;value&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 LocalStorage 删除保存的数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;key&#x27;</span>)                 <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 LocalStorage 删除所有保存的数据</span></span><br><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">clear</span>();</span><br></pre></td></tr></table></figure>


<h2 id="SessionStorage"><a href="#SessionStorage" class="headerlink" title="SessionStorage"></a>SessionStorage</h2><p><code>window.sessionStorage</code> 同样也遵循同源政策，它与 <code>window.localStorage</code> 不同的是，它在页面或浏览器关闭（会话结束）时就会被清除。<br><code>window.sessionStorage</code> 的使用如下例所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据到 SessionStorage</span></span><br><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 SessionStorage 获取数据</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 SessionStorage 删除保存的数据</span></span><br><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;key&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 SessionStorage 删除所有保存的数据</span></span><br><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">clear</span>()</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>四者之间的比较如下：</p>
<h3 id="Cookie-和-Session"><a href="#Cookie-和-Session" class="headerlink" title="Cookie 和 Session"></a>Cookie 和 Session</h3><ul>
<li>Cookie 保存在客户端的硬盘里；而 Session 是保存在服务端的内存里。</li>
<li>Cookie 每次都随着 HTTP 请求发送给服务器；而 Session 只需要通过发送保存在 Cookie 头中的 SessionID 即可从服务器中读取对应内存。</li>
<li>Cookie 以明文的形式存储，内容可以被用户查看或篡改；而 Session 因为只提供一个随机的 SessionID ，所以无法被用户直接查看。</li>
</ul>
<h3 id="Cookie-和-LocalStorage"><a href="#Cookie-和-LocalStorage" class="headerlink" title="Cookie 和 LocalStorage"></a>Cookie 和 LocalStorage</h3><ul>
<li>Cookie 的大小一般为 4KB ；而 LocalStorage 一般为 5MB 。</li>
<li>Cookie 一般在浏览器关闭（会话结束）时就失效，后端可以设置 <code>Expires</code> 或 <code>Max-Age</code> 来改变 Cookie 的过期时间；而 LocalStorage 是永久有效，除非用户手动清除。</li>
<li>Cookie 会被附加到 HTTP 请求中；而 LocalStorage 不会。</li>
</ul>
<h3 id="LocalStorage-和-SessionStorage"><a href="#LocalStorage-和-SessionStorage" class="headerlink" title="LocalStorage 和 SessionStorage"></a>LocalStorage 和 SessionStorage</h3><ul>
<li>前者永久有效，除非用户删除；后者在浏览器关闭（会话结束）后就被清空。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://caijialinxx.github.io/2018/07/16/cookie-session-webStorage/" data-id="cm2uc0mbo0005pggp7u8g4vrb" data-title="Cookie, Session, LocalStorage &amp; SessionStorage" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML5/" rel="tag">HTML5</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Notes/" rel="tag">Notes</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AJAX/" rel="tag">AJAX</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DOM/" rel="tag">DOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/" rel="tag">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/" rel="tag">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Notes/" rel="tag">Notes</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Promise/" rel="tag">Promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SEO/" rel="tag">SEO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Shell%E8%84%9A%E6%9C%AC/" rel="tag">Shell脚本</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TypeScript/" rel="tag">TypeScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debounce/" rel="tag">debounce</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/" rel="tag">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/throttle/" rel="tag">throttle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/troubleshooting/" rel="tag">troubleshooting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E5%9E%8B/" rel="tag">原型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B7%A5%E4%BD%9C/" rel="tag">工作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" rel="tag">深拷贝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%A7%E6%89%BF/" rel="tag">继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AJAX/" style="font-size: 11.67px;">AJAX</a> <a href="/tags/CSS/" style="font-size: 13.33px;">CSS</a> <a href="/tags/DOM/" style="font-size: 11.67px;">DOM</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/HTML/" style="font-size: 11.67px;">HTML</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/HTTP/" style="font-size: 13.33px;">HTTP</a> <a href="/tags/JavaScript/" style="font-size: 18.33px;">JavaScript</a> <a href="/tags/Notes/" style="font-size: 20px;">Notes</a> <a href="/tags/Promise/" style="font-size: 10px;">Promise</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/SEO/" style="font-size: 10px;">SEO</a> <a href="/tags/Shell%E8%84%9A%E6%9C%AC/" style="font-size: 10px;">Shell脚本</a> <a href="/tags/TypeScript/" style="font-size: 10px;">TypeScript</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/debounce/" style="font-size: 10px;">debounce</a> <a href="/tags/jQuery/" style="font-size: 10px;">jQuery</a> <a href="/tags/throttle/" style="font-size: 10px;">throttle</a> <a href="/tags/troubleshooting/" style="font-size: 10px;">troubleshooting</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a> <a href="/tags/%E5%8E%9F%E5%9E%8B/" style="font-size: 11.67px;">原型</a> <a href="/tags/%E5%B7%A5%E4%BD%9C/" style="font-size: 13.33px;">工作</a> <a href="/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" style="font-size: 10px;">深拷贝</a> <a href="/tags/%E7%BB%A7%E6%89%BF/" style="font-size: 11.67px;">继承</a> <a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 16.67px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/06/09/building-an-script-for-efficient-git-repository-synchronization/">为了高效同步代码仓库，我写了一个自动化脚本</a>
          </li>
        
          <li>
            <a href="/2023/03/24/troubleshooting/">命令行操作时遇到的一些报错解决方案（持续更新...）</a>
          </li>
        
          <li>
            <a href="/2022/05/02/react-17-important-changes/">React 17 的重要更新</a>
          </li>
        
          <li>
            <a href="/2021/10/02/typescript/">TypeScript 的使用心得及笔记</a>
          </li>
        
          <li>
            <a href="/2021/02/21/some-classfic-implements-with-js/">一些经典的JS手写函数实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 caijialinxx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>